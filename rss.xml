<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title></title>
        <link>undefined</link>
        <description>undefined</description>
        <lastBuildDate>Mon, 08 Jul 2024 09:39:02 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>Joplin Pages Publisher</generator>
        <item>
            <title><![CDATA[Code Analysis of HR Minesweeper Game problem solution]]></title>
            <guid>49d8495738504ab5b186660f525eb53a</guid>
            <pubDate>Wed, 03 Jul 2024 19:06:30 GMT</pubDate>
            <content:encoded><![CDATA[<p>Given the solution code :</p>
<div><pre class="hljs"><code><span class="hljs-keyword">import</span> java.util.Scanner;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Minesweeper</span> {
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">char</span>[][] map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];
        
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// Create a Scanner object for user input</span>
            <span class="hljs-type">Scanner</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);
            <span class="hljs-comment">// Read the number of bombs from user input</span>
            <span class="hljs-type">int</span> <span class="hljs-variable">numBombs</span> <span class="hljs-operator">=</span> input.nextInt();
            
            <span class="hljs-comment">// Populate the map with bombs based on user input</span>
            populateBombs(map, input, numBombs);
            <span class="hljs-comment">// Update the map with bomb counts</span>
            updateMapWithCounts(map);
            <span class="hljs-comment">// Print the updated map</span>
            printMap(map);
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-comment">// Handle any exceptions that occur during execution</span>
            System.out.println(<span class="hljs-string">"An error occurred: "</span> + e.getMessage());
        }
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">populateBombs</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] map, Scanner input, <span class="hljs-type">int</span> numBombs)</span> {
        <span class="hljs-comment">// Loop through the number of bombs provided by the user</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numBombs; i++) {
            <span class="hljs-comment">// Read the bomb coordinates from user input and mark them on the map</span>
            String[] bombCoord = input.next().split(<span class="hljs-string">","</span>);
            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> Integer.parseInt(bombCoord[<span class="hljs-number">0</span>]) - <span class="hljs-number">1</span>;
            <span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> Integer.parseInt(bombCoord[<span class="hljs-number">1</span>]) - <span class="hljs-number">1</span>;
            map[row][col] = <span class="hljs-string">'x'</span>;
        }
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateMapWithCounts</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] map)</span> {
        <span class="hljs-comment">// Iterate through each cell in the map</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) {
                <span class="hljs-comment">// Check if the cell is not a bomb</span>
                <span class="hljs-keyword">if</span> (map[i][j] != <span class="hljs-string">'x'</span>) {
                    <span class="hljs-comment">// Calculate the number of bombs around the cell</span>
                    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> countBombs(map, i, j);
                    <span class="hljs-comment">// Update the cell with the bomb count or '.' if no bombs nearby</span>
                    map[i][j] = count == <span class="hljs-number">0</span> ? <span class="hljs-string">'.'</span> : (<span class="hljs-type">char</span>)(<span class="hljs-string">'0'</span> + count);
                }
            }
        }
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printMap</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] map)</span> {
        <span class="hljs-comment">// Print the map to the console</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) {
                System.out.print(map[i][j]);
            }
            System.out.println();
        }
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countBombs</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] map, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span> {
        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
        <span class="hljs-comment">// Iterate through neighboring cells to count bombs</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">0</span>, row - <span class="hljs-number">1</span>); i &lt;= Math.min(<span class="hljs-number">9</span>, row + <span class="hljs-number">1</span>); i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">0</span>, col - <span class="hljs-number">1</span>); j &lt;= Math.min(<span class="hljs-number">9</span>, col + <span class="hljs-number">1</span>); j++) {
                <span class="hljs-comment">// Check if the cell contains a bomb</span>
                <span class="hljs-keyword">if</span> (map[i][j] == <span class="hljs-string">'x'</span>) {
                    count++;
                }
            }
        }
        <span class="hljs-keyword">return</span> count;
    }
}</code></pre></div>
<h2 id="elucidation">Elucidation</h2>
<p><strong>Explanation:</strong><br />
This Java program simulates a simple Minesweeper game where the user can input the number of bombs and their coordinates, and the program will populate the map with bombs and update the map with bomb counts around each cell.</p>
<ol>
<li>
<p><strong>Main Method:</strong></p>
<ul>
<li>The <code>main</code> method initializes a 10x10 char array to represent the game map.</li>
<li>It reads the number of bombs from the user, populates the bombs on the map, updates the map with bomb counts, and then prints the map.</li>
</ul>
</li>
<li>
<p><strong>Populate Bombs Method:</strong></p>
<ul>
<li>The <code>populateBombs</code> method takes the map, user input scanner, and the number of bombs as parameters.</li>
<li>It reads the bomb coordinates from the user input and marks those positions with ‘x’ on the map.</li>
</ul>
</li>
<li>
<p><strong>Update Map with Counts Method:</strong></p>
<ul>
<li>The <code>updateMapWithCounts</code> method iterates over each cell in the map.</li>
<li>For each empty cell (not a bomb), it calculates the number of bombs surrounding that cell and updates the cell with the bomb count or ‘.’ if no bombs are nearby.</li>
</ul>
</li>
<li>
<p><strong>Print Map Method:</strong></p>
<ul>
<li>The <code>printMap</code> method simply prints the current state of the map to the console.</li>
</ul>
</li>
<li>
<p><strong>Count Bombs Method:</strong></p>
<ul>
<li>The <code>countBombs</code> method calculates the number of bombs surrounding a particular cell by checking the neighboring cells within the bounds of the map.</li>
</ul>
</li>
</ol>
<p>This program efficiently handles user input for bomb placement, updates the map with bomb counts, and displays the final map state for the user to play the Minesweeper game.</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Code Analysis of HR Fraudulent Activity Notifications problem solution]]></title>
            <guid>06707c10ef61459ca94ace8a5d9c9e21</guid>
            <pubDate>Wed, 03 Jul 2024 10:36:25 GMT</pubDate>
            <content:encoded><![CDATA[<p>Given the solution code :</p>
<div><pre class="hljs"><code><span class="hljs-keyword">import</span> java.io.*;
<span class="hljs-keyword">import</span> java.math.*;
<span class="hljs-keyword">import</span> java.security.*;
<span class="hljs-keyword">import</span> java.text.*;
<span class="hljs-keyword">import</span> java.util.*;
<span class="hljs-keyword">import</span> java.util.concurrent.*;
<span class="hljs-keyword">import</span> java.util.regex.*;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Result</span> {

    <span class="hljs-comment">/*
     * Complete the 'activityNotifications' function below.
     *
     * The function is expected to return an INTEGER.
     * The function accepts following parameters:
     *  1. INTEGER_ARRAY expenditure
     *  2. INTEGER d
     */</span>

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">activityNotifications</span><span class="hljs-params">(List&lt;Integer&gt; expenditure, <span class="hljs-type">int</span> d)</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// Initialize variables</span>
            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
            <span class="hljs-type">int</span>[] freq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">201</span>];
            
            <span class="hljs-comment">// Initialize frequency array for initial expenditures</span>
            initializeFrequency(expenditure, d, freq);
            
            <span class="hljs-comment">// Calculate notifications based on median comparison</span>
            count = calculateNotifications(expenditure, d, freq);
            
            <span class="hljs-keyword">return</span> count;
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-comment">// Handle any exceptions that occur during the process</span>
            System.out.println(<span class="hljs-string">"An error occurred: "</span> + e.getMessage());
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
        }
    }

    <span class="hljs-comment">// Method to initialize frequency array for initial expenditures</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initializeFrequency</span><span class="hljs-params">(List&lt;Integer&gt; expenditure, <span class="hljs-type">int</span> d, <span class="hljs-type">int</span>[] freq)</span> {
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; d; i++) {
            freq[expenditure.get(i)]++;
        }
    }

    <span class="hljs-comment">// Method to calculate notifications based on median comparison</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateNotifications</span><span class="hljs-params">(List&lt;Integer&gt; expenditure, <span class="hljs-type">int</span> d, <span class="hljs-type">int</span>[] freq)</span> {
        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> d; i &lt; expenditure.size(); i++) {
            <span class="hljs-comment">// Calculate median based on frequency array</span>
            <span class="hljs-type">double</span> <span class="hljs-variable">median</span> <span class="hljs-operator">=</span> calculateMedian(freq, d);
            
            <span class="hljs-comment">// Compare expenditure with double the median for notification</span>
            <span class="hljs-keyword">if</span> (expenditure.get(i) &gt;= <span class="hljs-number">2</span> * median) {
                count++;
            }

            <span class="hljs-comment">// Update frequency array for sliding window</span>
            freq[expenditure.get(i - d)]--;
            freq[expenditure.get(i)]++;
        }
        <span class="hljs-keyword">return</span> count;
    }

    <span class="hljs-comment">// Method to calculate median based on frequency array</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calculateMedian</span><span class="hljs-params">(<span class="hljs-type">int</span>[] freq, <span class="hljs-type">int</span> d)</span> {
        <span class="hljs-type">double</span> <span class="hljs-variable">median</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (d % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) {
            <span class="hljs-comment">// Calculate median for odd window size</span>
            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">201</span>; j++) {
                sum += freq[j];
                <span class="hljs-keyword">if</span> (sum &gt;= d / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) {
                    median = j;
                    <span class="hljs-keyword">break</span>;
                }
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// Calculate median for even window size</span>
            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>, m = -<span class="hljs-number">1</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">201</span>; j++) {
                sum += freq[j];
                <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span> &amp;&amp; sum &gt;= d / <span class="hljs-number">2</span>) {
                    n = j;
                }
                <span class="hljs-keyword">if</span> (sum &gt;= d / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) {
                    m = j;
                    median = (m + n) / <span class="hljs-number">2.0</span>;
                    <span class="hljs-keyword">break</span>;
                }
            }
        }
        <span class="hljs-keyword">return</span> median;
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException {
        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));
        <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bufferedWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(System.getenv(<span class="hljs-string">"OUTPUT_PATH"</span>)));

        String[] firstMultipleInput = bufferedReader.readLine().replaceAll(<span class="hljs-string">"\\s+$"</span>, <span class="hljs-string">""</span>).split(<span class="hljs-string">" "</span>);

        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> Integer.parseInt(firstMultipleInput[<span class="hljs-number">0</span>]);

        <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> Integer.parseInt(firstMultipleInput[<span class="hljs-number">1</span>]);

        String[] expenditureTemp = bufferedReader.readLine().replaceAll(<span class="hljs-string">"\\s+$"</span>, <span class="hljs-string">""</span>).split(<span class="hljs-string">" "</span>);

        List&lt;Integer&gt; expenditure = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();

        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) {
            <span class="hljs-type">int</span> <span class="hljs-variable">expenditureItem</span> <span class="hljs-operator">=</span> Integer.parseInt(expenditureTemp[i]);
            expenditure.add(expenditureItem);
        }

        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Result.activityNotifications(expenditure, d);

        bufferedWriter.write(String.valueOf(result));
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}</code></pre></div>
<p><strong>Sample Input</strong></p>
<pre style="background:linear-gradient(to right, #F3F7EC, white);color:#3F4E4F;padding:5px" class="jop-noMdConv">
9 5                 
2 3 4 2 3 6 8 4 5
</pre>
<p><strong>Sample Output</strong></p>
<pre style="background:linear-gradient(to right, #FFE6E6, white);color:#3F4E4F;padding:5px" class="jop-noMdConv">
2
</pre>
<h2 id="elucidation">Elucidation</h2>
<p>The code provided is a Java implementation of a function called <code>activityNotifications</code> in the <code>Result</code> class. This function calculates the number of notifications that should be sent based on a set of expenditures and a given window size <code>d</code>. Here is a detailed explanation of the code:</p>
<ol>
<li>
<p><strong><code>activityNotifications</code> Method</strong>:</p>
<ul>
<li>This method is the main function that calculates the number of notifications to be sent.</li>
<li>It takes two parameters: <code>expenditure</code>, a list of expenditures, and <code>d</code>, the window size.</li>
<li>The method initializes variables, including <code>count</code> to store the notification count and <code>freq</code> to keep track of the frequency of expenditures.</li>
<li>It then calls two helper methods: <code>initializeFrequency</code> to set up the initial frequency array and <code>calculateNotifications</code> to determine the number of notifications.</li>
<li>Any exceptions that occur during the process are caught and handled with an error message.</li>
</ul>
</li>
<li>
<p><strong><code>initializeFrequency</code> Method</strong>:</p>
<ul>
<li>This method initializes the frequency array <code>freq</code> based on the initial <code>d</code> expenditures.</li>
<li>It loops through the first <code>d</code> expenditures and increments the corresponding frequency in the array.</li>
</ul>
</li>
<li>
<p><strong><code>calculateNotifications</code> Method</strong>:</p>
<ul>
<li>This method calculates the number of notifications based on median comparison.</li>
<li>It iterates through the expenditures starting from index <code>d</code>.</li>
<li>For each iteration, it calculates the median using the <code>calculateMedian</code> method and compares the current expenditure with double the median.</li>
<li>If the expenditure is greater than or equal to twice the median, it increments the <code>count</code> variable.</li>
<li>It updates the frequency array for the sliding window by removing the oldest expenditure and adding the new one.</li>
</ul>
</li>
<li>
<p><strong><code>calculateMedian</code> Method</strong>:</p>
<ul>
<li>This method calculates the median based on the frequency array <code>freq</code> and the window size <code>d</code>.</li>
<li>It handles both odd and even window sizes to determine the median value.</li>
<li>For an odd window size, it finds the middle value where the cumulative sum reaches <code>d/2 + 1</code>.</li>
<li>For an even window size, it finds the two middle values and calculates the average as the median.</li>
</ul>
</li>
</ol>
<p>Overall, the code structure is well-organized with separate methods for initialization, median calculation, and notification calculation. It efficiently handles the processing of expenditures and sliding windows to determine the number of notifications to be sent. The try-catch blocks ensure proper error handling during the execution of the function.</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Code Analysis of HR Queen's Attack II problem solution]]></title>
            <guid>b6316c68c275415a84854eda84032638</guid>
            <pubDate>Wed, 03 Jul 2024 10:17:35 GMT</pubDate>
            <content:encoded><![CDATA[<p>Given the solution code :</p>
<div><pre class="hljs"><code><span class="hljs-keyword">import</span> java.io.*;
<span class="hljs-keyword">import</span> java.math.*;
<span class="hljs-keyword">import</span> java.security.*;
<span class="hljs-keyword">import</span> java.text.*;
<span class="hljs-keyword">import</span> java.util.*;
<span class="hljs-keyword">import</span> java.util.concurrent.*;
<span class="hljs-keyword">import</span> java.util.function.*;
<span class="hljs-keyword">import</span> java.util.regex.*;
<span class="hljs-keyword">import</span> java.util.stream.*;
<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.util.stream.Collectors.joining;
<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.util.stream.Collectors.toList;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Result</span> {

    <span class="hljs-comment">/*
     * Complete the 'queensAttack' function below.
     *
     * The function is expected to return an INTEGER.
     * The function accepts following parameters:
     *  1. INTEGER n
     *  2. INTEGER k
     *  3. INTEGER r_q
     *  4. INTEGER c_q
     *  5. 2D_INTEGER_ARRAY obstacles
     */</span>

    <span class="hljs-comment">// Variable to store the total number of cells consumed</span>
    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">cellConsume</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;

    <span class="hljs-comment">// Method to calculate the queen's attack</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">queensAttack</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> r_q, <span class="hljs-type">int</span> c_q, List&lt;List&lt;Integer&gt;&gt; obstacles)</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// Convert obstacles into a map for efficient lookup</span>
            HashMap&lt;Integer, List&lt;Integer&gt;&gt; obstaclesMap = convertObstaclesIntoMap(obstacles);

            <span class="hljs-comment">// Check for obstacles in different directions</span>
            leftIteration(r_q, c_q, obstaclesMap);
            bottomIteration(r_q, c_q, obstaclesMap);
            southWestIteration(r_q, c_q, obstaclesMap);
            northWestIteration(r_q, c_q, n, obstaclesMap);
            topIteration(r_q, c_q, n, obstaclesMap);
            northEastIteration(r_q, c_q, n, obstaclesMap);
            rightIteration(r_q, c_q, n, obstaclesMap);
            southEastIteration(r_q, c_q, n, obstaclesMap);
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-comment">// Handle any exceptions that occur during the process</span>
            System.out.println(<span class="hljs-string">"An error occurred: "</span> + e.getMessage());
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">return</span> cellConsume;
    }

    <span class="hljs-comment">// Method to convert obstacles into a map for efficient lookup</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> HashMap&lt;Integer, List&lt;Integer&gt;&gt; <span class="hljs-title function_">convertObstaclesIntoMap</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; obstacles)</span> {
        <span class="hljs-comment">// Initialize a HashMap to store obstacles for efficient lookup</span>
        HashMap&lt;Integer, List&lt;Integer&gt;&gt; obstaclesMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();

        <span class="hljs-comment">// Iterate through the list of obstacles to populate the map</span>
        obstacles.forEach(x -&gt; {
            obstaclesMap.compute(x.get(<span class="hljs-number">0</span>), (k, existingList) -&gt; {
                <span class="hljs-comment">// If the key is not present, create a new list with the obstacle column value</span>
                <span class="hljs-keyword">if</span> (existingList == <span class="hljs-literal">null</span>) {
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Collections.singletonList(x.get(<span class="hljs-number">1</span>)));
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-comment">// If the key exists, add the obstacle column value to the existing list</span>
                    existingList.add(x.get(<span class="hljs-number">1</span>));
                    <span class="hljs-keyword">return</span> existingList;
                }
            });
        });

        <span class="hljs-keyword">return</span> obstaclesMap;
    }

    <span class="hljs-comment">// Method to check for obstacles in the left direction</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">leftIteration</span><span class="hljs-params">(<span class="hljs-type">int</span> r_q, <span class="hljs-type">int</span> c_q, HashMap&lt;Integer, List&lt;Integer&gt;&gt; obstacles)</span> {
        <span class="hljs-comment">// Iterate to the left from the queen's position</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> r_q, c = c_q - <span class="hljs-number">1</span>; c &gt;= <span class="hljs-number">1</span>; c--) {
            <span class="hljs-comment">// Check if there is an obstacle at the current position</span>
            <span class="hljs-keyword">if</span> (obstacles.get(r) != <span class="hljs-literal">null</span> &amp;&amp; obstacles.get(r).contains(c)) {
                <span class="hljs-comment">// If obstacle is present, stop further iteration in this direction</span>
                <span class="hljs-keyword">return</span>;
            }
            <span class="hljs-comment">// Increment the total cells consumed</span>
            cellConsume++;
        }
    }

    <span class="hljs-comment">// Method to check for obstacles in the bottom direction</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bottomIteration</span><span class="hljs-params">(<span class="hljs-type">int</span> r_q, <span class="hljs-type">int</span> c_q, Map&lt;Integer, List&lt;Integer&gt;&gt; obstacles)</span> {
        <span class="hljs-comment">// Iterate from the queen's position downwards</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> r_q - <span class="hljs-number">1</span>, c = c_q; r &gt;= <span class="hljs-number">1</span>; r--) {
            <span class="hljs-comment">// Check if there is an obstacle at the current position</span>
            <span class="hljs-keyword">if</span> (obstacles.get(r) != <span class="hljs-literal">null</span> &amp;&amp; obstacles.get(r).contains(c)) {
                <span class="hljs-comment">// If obstacle is present, stop further iteration in this direction</span>
                <span class="hljs-keyword">return</span>;
            }
            <span class="hljs-comment">// Increment the total cells consumed</span>
            cellConsume++;
        }
    }

    <span class="hljs-comment">// Method to check for obstacles in the southwest direction</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">southWestIteration</span><span class="hljs-params">(<span class="hljs-type">int</span> r_q, <span class="hljs-type">int</span> c_q, HashMap&lt;Integer, List&lt;Integer&gt;&gt; obstacles)</span> {
        <span class="hljs-comment">// Iterate diagonally towards the southwest direction</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> r_q - <span class="hljs-number">1</span>, c = c_q - <span class="hljs-number">1</span>; r &gt;= <span class="hljs-number">1</span> &amp;&amp; c &gt;= <span class="hljs-number">1</span>; r--, c--) {
            <span class="hljs-comment">// Check for obstacles at the current diagonal position</span>
            <span class="hljs-keyword">if</span> (obstacles.get(r) != <span class="hljs-literal">null</span> &amp;&amp; obstacles.get(r).contains(c)) {
                <span class="hljs-comment">// If obstacle is present, stop further iteration in this direction</span>
                <span class="hljs-keyword">return</span>;
            }
            <span class="hljs-comment">// Increment the total cells consumed</span>
            cellConsume++;
        }
    }

    <span class="hljs-comment">// Method to check for obstacles in the northwest direction</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">northWestIteration</span><span class="hljs-params">(<span class="hljs-type">int</span> r_q, <span class="hljs-type">int</span> c_q, <span class="hljs-type">int</span> n, HashMap&lt;Integer, List&lt;Integer&gt;&gt; obstacles)</span> {
        <span class="hljs-comment">// Iterate diagonally towards the northwest direction</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> r_q + <span class="hljs-number">1</span>, c = c_q - <span class="hljs-number">1</span>; r &lt;= n &amp;&amp; c &gt;= <span class="hljs-number">1</span>; r++, c--) {
            <span class="hljs-comment">// Check for obstacles at the current diagonal position</span>
            <span class="hljs-keyword">if</span> (obstacles.get(r) != <span class="hljs-literal">null</span> &amp;&amp; obstacles.get(r).contains(c)) {
                <span class="hljs-comment">// If obstacle is present, stop further iteration in this direction</span>
                <span class="hljs-keyword">return</span>;
            }
            <span class="hljs-comment">// Increment the total cells consumed</span>
            cellConsume++;
        }
    }

    <span class="hljs-comment">// Method to check for obstacles in the top direction</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">topIteration</span><span class="hljs-params">(<span class="hljs-type">int</span> r_q, <span class="hljs-type">int</span> c_q, <span class="hljs-type">int</span> n, HashMap&lt;Integer, List&lt;Integer&gt;&gt; obstacles)</span> {
        <span class="hljs-comment">// Iterate upwards from the queen's position</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> r_q + <span class="hljs-number">1</span>, c = c_q; r &lt;= n; r++) {
            <span class="hljs-comment">// Check if there is an obstacle at the current position</span>
            <span class="hljs-keyword">if</span> (obstacles.get(r) != <span class="hljs-literal">null</span> &amp;&amp; obstacles.get(r).contains(c)) {
                <span class="hljs-comment">// If obstacle is present, stop further iteration in this direction</span>
                <span class="hljs-keyword">return</span>;
            }
            <span class="hljs-comment">// Increment the total cells consumed</span>
            cellConsume++;
        }
    }

    <span class="hljs-comment">// Method to check for obstacles in the northeast direction</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">northEastIteration</span><span class="hljs-params">(<span class="hljs-type">int</span> r_q, <span class="hljs-type">int</span> c_q, <span class="hljs-type">int</span> n, HashMap&lt;Integer, List&lt;Integer&gt;&gt; obstacles)</span> {
        <span class="hljs-comment">// Iterate diagonally towards the northeast direction</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> r_q + <span class="hljs-number">1</span>, c = c_q + <span class="hljs-number">1</span>; r &lt;= n &amp;&amp; c &lt;= n; r++, c++) {
            <span class="hljs-comment">// Check for obstacles at the current diagonal position</span>
            <span class="hljs-keyword">if</span> (obstacles.get(r) != <span class="hljs-literal">null</span> &amp;&amp; obstacles.get(r).contains(c)) {
                <span class="hljs-comment">// If obstacle is present, stop further iteration in this direction</span>
                <span class="hljs-keyword">return</span>;
            }
            <span class="hljs-comment">// Increment the total cells consumed</span>
            cellConsume++;
        }
    }

    <span class="hljs-comment">// Method to check for obstacles in the right direction</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rightIteration</span><span class="hljs-params">(<span class="hljs-type">int</span> r_q, <span class="hljs-type">int</span> c_q, <span class="hljs-type">int</span> n, HashMap&lt;Integer, List&lt;Integer&gt;&gt; obstacles)</span> {
        <span class="hljs-comment">// Iterate to the right from the queen's position</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> r_q, c = c_q + <span class="hljs-number">1</span>; c &lt;= n; c++) {
            <span class="hljs-comment">// Check if there is an obstacle at the current position</span>
            <span class="hljs-keyword">if</span> (obstacles.get(r) != <span class="hljs-literal">null</span> &amp;&amp; obstacles.get(r).contains(c)) {
                <span class="hljs-comment">// If obstacle is present, stop further iteration in this direction</span>
                <span class="hljs-keyword">return</span>;
            }
            <span class="hljs-comment">// Increment the total cells consumed</span>
            cellConsume++;
        }
    }

    <span class="hljs-comment">// Method to check for obstacles in the southeast direction</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">southEastIteration</span><span class="hljs-params">(<span class="hljs-type">int</span> r_q, <span class="hljs-type">int</span> c_q, <span class="hljs-type">int</span> n, HashMap&lt;Integer, List&lt;Integer&gt;&gt; obstacles)</span> {
        <span class="hljs-comment">// Iterate diagonally towards the southeast direction</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> r_q - <span class="hljs-number">1</span>, c = c_q + <span class="hljs-number">1</span>; r &gt;= <span class="hljs-number">1</span> &amp;&amp; c &lt;= n; r--, c++) {
            <span class="hljs-comment">// Check for obstacles at the current diagonal position</span>
            <span class="hljs-keyword">if</span> (obstacles.get(r) != <span class="hljs-literal">null</span> &amp;&amp; obstacles.get(r).contains(c)) {
                <span class="hljs-comment">// If obstacle is present, stop further iteration in this direction</span>
                <span class="hljs-keyword">return</span>;
            }
            <span class="hljs-comment">// Increment the total cells consumed</span>
            cellConsume++;
        }
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException {
        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));
        <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bufferedWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(System.getenv(<span class="hljs-string">"OUTPUT_PATH"</span>)));

        String[] firstMultipleInput = bufferedReader.readLine().replaceAll(<span class="hljs-string">"\\s+$"</span>, <span class="hljs-string">""</span>).split(<span class="hljs-string">" "</span>);

        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> Integer.parseInt(firstMultipleInput[<span class="hljs-number">0</span>]);

        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> Integer.parseInt(firstMultipleInput[<span class="hljs-number">1</span>]);

        String[] secondMultipleInput = bufferedReader.readLine().replaceAll(<span class="hljs-string">"\\s+$"</span>, <span class="hljs-string">""</span>).split(<span class="hljs-string">" "</span>);

        <span class="hljs-type">int</span> <span class="hljs-variable">r_q</span> <span class="hljs-operator">=</span> Integer.parseInt(secondMultipleInput[<span class="hljs-number">0</span>]);

        <span class="hljs-type">int</span> <span class="hljs-variable">c_q</span> <span class="hljs-operator">=</span> Integer.parseInt(secondMultipleInput[<span class="hljs-number">1</span>]);

        List&lt;List&lt;Integer&gt;&gt; obstacles = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();

        IntStream.range(<span class="hljs-number">0</span>, k).forEach(i -&gt; {
            <span class="hljs-keyword">try</span> {
                obstacles.add(
                    Stream.of(bufferedReader.readLine().replaceAll(<span class="hljs-string">"\\s+$"</span>, <span class="hljs-string">""</span>).split(<span class="hljs-string">" "</span>))
                        .map(Integer::parseInt)
                        .collect(toList())
                );
            } <span class="hljs-keyword">catch</span> (IOException ex) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(ex);
            }
        });

        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Result.queensAttack(n, k, r_q, c_q, obstacles);

        bufferedWriter.write(String.valueOf(result));
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}</code></pre></div>
<p><strong>Sample Input</strong></p>
<pre style="background:linear-gradient(to right, #F3F7EC, white);color:#3F4E4F;padding:5px" class="jop-noMdConv">
4 0
4 4
</pre>
<p><strong>Sample Output</strong></p>
<pre style="background:linear-gradient(to right, #FFE6E6, white);color:#3F4E4F;padding:5px" class="jop-noMdConv">
9
</pre>
<h2 id="elucidation">Elucidation</h2>
<p>Here is a detailed explanation of the provided code:</p>
<ol>
<li>
<p><strong>Result Class</strong>:</p>
<ul>
<li>The <code>Result</code> class contains methods to calculate the queen’s attack in different directions and handle obstacles efficiently.</li>
<li>It uses a static variable <code>cellConsume</code> to store the total number of cells consumed during the queen’s attack.</li>
<li>The <code>queensAttack</code> method is the main method that orchestrates the calculation of the queen’s attack in various directions.</li>
<li>It converts the obstacles into a map for efficient lookup and then checks for obstacles in different directions using separate methods.</li>
<li>Each direction checking method increments the <code>cellConsume</code> counter based on the number of cells consumed.</li>
<li>The <code>queensAttack</code> method returns the total <code>cellConsume</code> count after calculating the queen’s attack.</li>
</ul>
</li>
<li>
<p><strong>Solution Class</strong>:</p>
<ul>
<li>The <code>Solution</code> class contains the <code>main</code> method, which is the entry point of the program.</li>
<li>It reads input from the standard input (console) to get the board size, queen’s position, and obstacles.</li>
<li>The obstacles are stored in a list of lists representing their positions on the board.</li>
<li>The <code>queensAttack</code> method from the <code>Result</code> class is called to calculate the total number of cells consumed during the queen’s attack.</li>
<li>The result is written to the standard output (console) using a <code>BufferedWriter</code>.</li>
</ul>
</li>
</ol>
<p>Overall, the code efficiently calculates the queen’s attack by considering obstacles in different directions and provides the total number of cells consumed during the attack. The code structure separates the logic into distinct methods for better readability and maintainability.</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Code Analysis of HR Candies problem solution]]></title>
            <guid>776aded309ab4d28b8e9749a8e2aee0b</guid>
            <pubDate>Wed, 03 Jul 2024 09:23:26 GMT</pubDate>
            <content:encoded><![CDATA[<p>Given the solution code :</p>
<div><pre class="hljs"><code><span class="hljs-keyword">import</span> java.io.*;
<span class="hljs-keyword">import</span> java.math.*;
<span class="hljs-keyword">import</span> java.security.*;
<span class="hljs-keyword">import</span> java.text.*;
<span class="hljs-keyword">import</span> java.util.*;
<span class="hljs-keyword">import</span> java.util.concurrent.*;
<span class="hljs-keyword">import</span> java.util.regex.*;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Result</span> {

    <span class="hljs-comment">/*
     * Complete the 'candies' function below.
     *
     * The function is expected to return a LONG_INTEGER.
     * The function accepts following parameters:
     *  1. INTEGER n
     *  2. INTEGER_ARRAY arr
     */</span>

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">candies</span><span class="hljs-params">(<span class="hljs-type">int</span> n, List&lt;Integer&gt; arr)</span> {
        <span class="hljs-comment">// Initialize variables for streaks and total candies</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">streakUp</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, streakDown = <span class="hljs-number">1</span>, lastStreakUp = <span class="hljs-number">1</span>;
        <span class="hljs-type">long</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; 

        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// Iterate through the array</span>
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n-<span class="hljs-number">1</span>; i++){            
                <span class="hljs-comment">// Check if the current element is greater than the next element</span>
                <span class="hljs-keyword">if</span>(arr.get(i) &gt; arr.get(i+<span class="hljs-number">1</span>)){                    
                    streakDown++;                            
                    <span class="hljs-keyword">if</span>(lastStreakUp &gt; streakDown-<span class="hljs-number">1</span>){                            
                        total += streakDown-<span class="hljs-number">1</span>;                                    
                    } <span class="hljs-keyword">else</span> { 
                        total += streakDown;
                    }                                
                    streakUp = <span class="hljs-number">1</span>;
                }                        
                <span class="hljs-comment">// Check if the current element is less than the next element</span>
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr.get(i) &lt; arr.get(i+<span class="hljs-number">1</span>)){                        
                    streakUp++;
                    streakDown = <span class="hljs-number">1</span>;
                    total += streakUp;
                    lastStreakUp = streakUp;                                
                }
                <span class="hljs-comment">// Handle the case when the elements are equal</span>
                <span class="hljs-keyword">else</span> {                    
                    streakUp = streakDown = lastStreakUp = <span class="hljs-number">1</span>;
                    total++;                            
                }
            }
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-comment">// Handle any exceptions that occur during the process</span>
            System.out.println(<span class="hljs-string">"An error occurred: "</span> + e.getMessage());
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
        }

        <span class="hljs-keyword">return</span> total;
    }

}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException {
        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));
        <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bufferedWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(System.getenv(<span class="hljs-string">"OUTPUT_PATH"</span>)));

        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> Integer.parseInt(bufferedReader.readLine().trim());

        List&lt;Integer&gt; arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();

        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) {
            <span class="hljs-type">int</span> <span class="hljs-variable">arrItem</span> <span class="hljs-operator">=</span> Integer.parseInt(bufferedReader.readLine().trim());
            arr.add(arrItem);
        }

        <span class="hljs-type">long</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Result.candies(n, arr);

        bufferedWriter.write(String.valueOf(result));
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}</code></pre></div>
<p><strong>Sample Input</strong></p>
<pre style="background:linear-gradient(to right, #F3F7EC, white);color:#3F4E4F;padding:5px" class="jop-noMdConv">
3
1
2
2
</pre>
<p><strong>Sample Output</strong></p>
<pre style="background:linear-gradient(to right, #FFE6E6, white);color:#3F4E4F;padding:5px" class="jop-noMdConv">
4
</pre>
<h2 id="elucidation">Elucidation</h2>
<ol>
<li>
<p><strong>Result Class</strong>:</p>
<ul>
<li>The <code>Result</code> class contains a static method <code>candies</code> that calculates the total number of candies to be distributed based on the given array of ratings.</li>
<li>The method takes two parameters: <code>n</code> (the number of elements in the array) and <code>arr</code> (the list of ratings).</li>
<li>It initializes variables for streaks of increasing and decreasing ratings, along with the total number of candies.</li>
<li>The method iterates through the array to calculate the total number of candies based on the streaks of ratings.</li>
<li>It handles cases where the current rating is greater than, less than, or equal to the next rating.</li>
<li>The method uses try-catch blocks to handle any exceptions that may occur during the process.</li>
</ul>
</li>
<li>
<p><strong>Solution Class</strong>:</p>
<ul>
<li>The <code>Solution</code> class contains the <code>main</code> method, which is the entry point of the program.</li>
<li>It reads input from the standard input (console) using a <code>BufferedReader</code> and parses the input to get the number of elements <code>n</code> and the list of ratings <code>arr</code>.</li>
<li>The ratings are stored in an <code>ArrayList</code>.</li>
<li>The <code>candies</code> method from the <code>Result</code> class is called to calculate the total number of candies based on the ratings.</li>
<li>The result is written to the standard output (console) using a <code>BufferedWriter</code>.</li>
</ul>
</li>
</ol>
<p>Overall, the code structure separates the logic for calculating candies into the <code>Result</code> class and handles input/output operations in the <code>Solution</code> class. The <code>candies</code> method efficiently calculates the total number of candies based on the streaks of increasing and decreasing ratings in the input array. The <code>main</code> method reads input, processes it, and writes the result to the output.</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Code Analysis of HR Goodland Electricity problem solution]]></title>
            <guid>326bba3fc113446e829114782bb534bc</guid>
            <pubDate>Wed, 03 Jul 2024 07:15:22 GMT</pubDate>
            <content:encoded><![CDATA[<p>Given the solution code :</p>
<div><pre class="hljs"><code><span class="hljs-keyword">import</span> java.io.*;
<span class="hljs-keyword">import</span> java.math.*;
<span class="hljs-keyword">import</span> java.security.*;
<span class="hljs-keyword">import</span> java.text.*;
<span class="hljs-keyword">import</span> java.util.*;
<span class="hljs-keyword">import</span> java.util.concurrent.*;
<span class="hljs-keyword">import</span> java.util.regex.*;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Result</span> {

    <span class="hljs-comment">/*
     * Complete the 'pylons' function below.
     *
     * The function is expected to return an INTEGER.
     * The function accepts following parameters:
     *  1. INTEGER k
     *  2. INTEGER_ARRAY arr
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pylons</span><span class="hljs-params">(<span class="hljs-type">int</span> k, List&lt;Integer&gt; arr)</span> {
        <span class="hljs-comment">// Initialize count of pylons</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
        <span class="hljs-comment">// Initialize the previous pylon location</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">prevLoc</span> <span class="hljs-operator">=</span> -k;        

        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// Iterate through the array</span>
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;arr.size(); i++){
                <span class="hljs-comment">// Calculate the maximum coverage range</span>
                <span class="hljs-type">int</span> <span class="hljs-variable">maxCoverage</span> <span class="hljs-operator">=</span> prevLoc+k;

                <span class="hljs-comment">// Skip if within the coverage range</span>
                <span class="hljs-keyword">if</span>(i &lt; maxCoverage)
                    <span class="hljs-keyword">continue</span>;

                <span class="hljs-comment">// Search for pylons within the coverage range</span>
                <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Math.min(arr.size()-<span class="hljs-number">1</span>, i+k-<span class="hljs-number">1</span>);
                <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">0</span>, i-(k-<span class="hljs-number">1</span>));
                <span class="hljs-type">int</span> <span class="hljs-variable">pylonIndex</span> <span class="hljs-operator">=</span> findPylonInRange(arr, max, min);

                <span class="hljs-comment">// If a pylon is found, update count and previous location</span>
                <span class="hljs-keyword">if</span> (pylonIndex != -<span class="hljs-number">1</span>) {
                    count++;
                    prevLoc = pylonIndex;
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-comment">// If no pylon is found, return -1</span>
                    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
                }
            }
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-comment">// Handle any exceptions that occur during the process</span>
            System.out.println(<span class="hljs-string">"An error occurred: "</span> + e.getMessage());
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
        }

        <span class="hljs-keyword">return</span> count;
    }

    <span class="hljs-comment">// Method to find a pylon within the specified range</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findPylonInRange</span><span class="hljs-params">(List&lt;Integer&gt; arr, <span class="hljs-type">int</span> max, <span class="hljs-type">int</span> min)</span> {
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=max; j&gt;=min; j--){
            <span class="hljs-keyword">if</span>(arr.get(j) == <span class="hljs-number">1</span>){
                <span class="hljs-keyword">return</span> j;
            }
        }
        <span class="hljs-comment">// Return -1 if no pylon is found within the range</span>
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }

}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException {
        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));
        <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bufferedWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(System.getenv(<span class="hljs-string">"OUTPUT_PATH"</span>)));

        String[] firstMultipleInput = bufferedReader.readLine().replaceAll(<span class="hljs-string">"\\s+$"</span>, <span class="hljs-string">""</span>).split(<span class="hljs-string">" "</span>);

        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> Integer.parseInt(firstMultipleInput[<span class="hljs-number">0</span>]);

        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> Integer.parseInt(firstMultipleInput[<span class="hljs-number">1</span>]);

        String[] arrTemp = bufferedReader.readLine().replaceAll(<span class="hljs-string">"\\s+$"</span>, <span class="hljs-string">""</span>).split(<span class="hljs-string">" "</span>);

        List&lt;Integer&gt; arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();

        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) {
            <span class="hljs-type">int</span> <span class="hljs-variable">arrItem</span> <span class="hljs-operator">=</span> Integer.parseInt(arrTemp[i]);
            arr.add(arrItem);
        }

        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Result.pylons(k, arr);

        bufferedWriter.write(String.valueOf(result));
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}</code></pre></div>
<p><strong>Sample Input</strong></p>
<pre style="background:linear-gradient(to right, #F3F7EC, white);color:#3F4E4F;padding:5px" class="jop-noMdConv">
6 2           
0 1 1 1 1 0
</pre>
<p><strong>Sample Output</strong></p>
<pre style="background:linear-gradient(to right, #FFE6E6, white);color:#3F4E4F;padding:5px" class="jop-noMdConv">
2
</pre>
<h2 id="elucidation">Elucidation</h2>
<ol>
<li>
<p><strong>pylons Method</strong>:</p>
<ul>
<li>The <code>pylons</code> method takes two parameters: <code>k</code> (an integer representing the coverage range) and <code>arr</code> (a list of integers representing the presence of pylons).</li>
<li>It initializes the count of pylons (<code>count</code>) to 0 and the previous pylon location (<code>prevLoc</code>) to a value before the start of the array.</li>
<li>The method uses a try-catch block to handle any exceptions that may occur during the process.</li>
<li>It iterates through the array to find pylons within the coverage range.</li>
<li>If a pylon is found within the range, the count is incremented, and the previous location is updated.</li>
<li>If no pylon is found within the range, the method returns -1.</li>
</ul>
</li>
<li>
<p><strong>findPylonInRange Method</strong>:</p>
<ul>
<li>The <code>findPylonInRange</code> method takes three parameters: <code>arr</code> (the list of integers representing pylons), <code>max</code> (the maximum index to search), and <code>min</code> (the minimum index to search).</li>
<li>It iterates through the array from the maximum index to the minimum index to find a pylon.</li>
<li>If a pylon is found, it returns the index of the pylon. Otherwise, it returns -1.</li>
</ul>
</li>
</ol>
<p>Overall, the <code>pylons</code> method efficiently searches for pylons within the specified coverage range by breaking down the process into smaller methods and handling exceptions gracefully. The <code>findPylonInRange</code> method simplifies the search for pylons within a specific range, improving the readability and maintainability of the code.</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Code Analysis of HR Crossword Puzzle problem solution]]></title>
            <guid>e062ed7284394371b1e0a630286cdcd4</guid>
            <pubDate>Wed, 03 Jul 2024 05:35:27 GMT</pubDate>
            <content:encoded><![CDATA[<p>Given the solution code :</p>
<div><pre class="hljs"><code><span class="hljs-keyword">import</span> java.io.*;
<span class="hljs-keyword">import</span> java.math.*;
<span class="hljs-keyword">import</span> java.security.*;
<span class="hljs-keyword">import</span> java.text.*;
<span class="hljs-keyword">import</span> java.util.*;
<span class="hljs-keyword">import</span> java.util.concurrent.*;
<span class="hljs-keyword">import</span> java.util.regex.*;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Result</span> {

    <span class="hljs-keyword">static</span> List&lt;String&gt; result;
    <span class="hljs-comment">/*
     * Complete the 'crosswordPuzzle' function below.
     *
     * The function is expected to return a STRING_ARRAY.
     * The function accepts following parameters:
     *  1. STRING_ARRAY crossword
     *  2. STRING words
     */</span>    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title function_">crosswordPuzzle</span><span class="hljs-params">(List&lt;String&gt; crossword, String words)</span> {
        <span class="hljs-comment">// Function to solve the crossword puzzle</span>
        result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">// Initialize the result to store the solved puzzle</span>
        <span class="hljs-type">char</span>[][] croswrd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>]; <span class="hljs-comment">// Create a 10x10 crossword grid</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
        <span class="hljs-comment">// Populate the crossword grid with characters from the input</span>
        <span class="hljs-keyword">for</span> (String s : crossword) {
            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : s.toCharArray()) {
                croswrd[i][j] = ch;
                j++;
            }
            i++;
        }
        <span class="hljs-keyword">try</span> {
            helper(croswrd, words.split(<span class="hljs-string">";"</span>), <span class="hljs-number">0</span>); <span class="hljs-comment">// Call the helper function to solve the puzzle</span>
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-comment">// Handle any exceptions that occur during the solving process</span>
            System.out.println(<span class="hljs-string">"An error occurred: "</span> + e.getMessage());
        }
        <span class="hljs-keyword">return</span> result; <span class="hljs-comment">// Return the solved crossword puzzle</span>
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] c, String[] words, <span class="hljs-type">int</span> vidx)</span> {
        <span class="hljs-comment">// Recursive helper function to solve the crossword puzzle</span>
        <span class="hljs-keyword">if</span> (vidx == words.length) {
            <span class="hljs-comment">// If all words are placed, convert the crossword grid to a list of strings</span>
            List&lt;String&gt; temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span>[] str : c) {
                <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">""</span>;
                <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : str) {
                    s += ch;
                }
                temp.add(s);
            }
            result = temp; <span class="hljs-comment">// Update the result with the solved puzzle</span>
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-type">String</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> words[vidx]; <span class="hljs-comment">// Get the current word to be placed</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">9</span>; i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">9</span>; j++) {
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-comment">// Try placing the word horizontally if possible</span>
                    <span class="hljs-keyword">if</span> (canPutHorizontally(c, word, i, j)) {
                        <span class="hljs-type">boolean</span>[][] vis = putHorizontally(c, word, i, j); <span class="hljs-comment">// Track the placement</span>
                        helper(c, words, vidx + <span class="hljs-number">1</span>); <span class="hljs-comment">// Recursively call helper for the next word</span>
                        replaceHorizontal(c, word, vis, i, j); <span class="hljs-comment">// Backtrack and replace if needed</span>
                    }

                    <span class="hljs-comment">// Try placing the word vertically if possible</span>
                    <span class="hljs-keyword">if</span> (canPutVertically(c, word, i, j)) {
                        <span class="hljs-type">boolean</span>[][] vis = putVertically(c, word, i, j); <span class="hljs-comment">// Track the placement</span>
                        helper(c, words, vidx + <span class="hljs-number">1</span>); <span class="hljs-comment">// Recursively call helper for the next word</span>
                        replaceVertical(c, word, vis, i, j); <span class="hljs-comment">// Backtrack and replace if needed</span>
                    }
                } <span class="hljs-keyword">catch</span> (Exception e) {
                    System.out.println(<span class="hljs-string">"An error occurred: "</span> + e.getMessage());
                }
            }
        }
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">replaceHorizontal</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] c, String word, <span class="hljs-type">boolean</span>[][] vis, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// Replace the characters in the horizontal direction for the word</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; word.length(); k++) {
                <span class="hljs-keyword">if</span> (vis[i][j + k]) {
                    <span class="hljs-comment">// Replace the character with a dash and update the visibility array</span>
                    c[i][j + k] = <span class="hljs-string">'-'</span>;
                    vis[i][j + k] = <span class="hljs-literal">false</span>;
                }
            }
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-comment">// Handle any exceptions that occur during horizontal replacement</span>
            System.out.println(<span class="hljs-string">"An error occurred in replaceHorizontal: "</span> + e.getMessage());
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">replaceVertical</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] c, String word, <span class="hljs-type">boolean</span>[][] vis, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// Replace the characters in the vertical direction for the word</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; word.length(); k++) {
                <span class="hljs-keyword">if</span> (vis[i + k][j]) {
                    <span class="hljs-comment">// Replace the character with a dash and update the visibility array</span>
                    c[i + k][j] = <span class="hljs-string">'-'</span>;
                    vis[i + k][j] = <span class="hljs-literal">false</span>;
                }
            }
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-comment">// Handle any exceptions that occur during vertical replacement</span>
            System.out.println(<span class="hljs-string">"An error occurred in replaceVertical: "</span> + e.getMessage());
        }
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span>[][] putHorizontally(<span class="hljs-type">char</span>[][] c, String word, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j) {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// Create a boolean array to track the placement of characters for the word horizontally</span>
            <span class="hljs-type">boolean</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; word.length(); k++) {
                <span class="hljs-comment">// Check if it's within the bounds and the current position is empty</span>
                <span class="hljs-keyword">if</span> (j + k &lt; <span class="hljs-number">10</span> &amp;&amp; c[i][j + k] == <span class="hljs-string">'-'</span>) {
                    <span class="hljs-comment">// Place the character from the word at the corresponding position</span>
                    c[i][j + k] = word.charAt(k);
                    res[i][j + k] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// Update the tracking array</span>
                }
            }
            <span class="hljs-keyword">return</span> res; <span class="hljs-comment">// Return the tracking array</span>
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-comment">// Handle any exceptions that occur during the horizontal placement</span>
            System.out.println(<span class="hljs-string">"An error occurred in putHorizontally: "</span> + e.getMessage());
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>]; <span class="hljs-comment">// Return an empty tracking array</span>
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span>[][] putVertically(<span class="hljs-type">char</span>[][] c, String word, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j) {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// Create a boolean array to track the placement of characters for the word vertically</span>
            <span class="hljs-type">boolean</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; word.length(); k++) {
                <span class="hljs-comment">// Check if it's within the bounds and the current position is empty</span>
                <span class="hljs-keyword">if</span> (i + k &lt; <span class="hljs-number">10</span> &amp;&amp; c[i + k][j] == <span class="hljs-string">'-'</span>) {
                    <span class="hljs-comment">// Place the character from the word at the corresponding position</span>
                    c[i + k][j] = word.charAt(k);
                    res[i + k][j] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// Update the tracking array</span>
                }
            }
            <span class="hljs-keyword">return</span> res; <span class="hljs-comment">// Return the tracking array</span>
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-comment">// Handle any exceptions that occur during the vertical placement</span>
            System.out.println(<span class="hljs-string">"An error occurred in putVertically: "</span> + e.getMessage());
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>]; <span class="hljs-comment">// Return an empty tracking array</span>
        }
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canPutHorizontally</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] c, String word, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// Check if the word can be placed horizontally at position i, j on the crossword</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; word.length(); k++) {
                <span class="hljs-keyword">if</span> (j + k &lt; <span class="hljs-number">10</span> &amp;&amp; (c[i][j + k] == <span class="hljs-string">'-'</span> || c[i][j + k] == word.charAt(k))) {
                    <span class="hljs-comment">// Continue checking the next character in the word</span>
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-comment">// Return false if the word cannot be placed horizontally at the current position</span>
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }
            }
            <span class="hljs-comment">// Return true if the word can be placed horizontally at the given position</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-comment">// Handle any exceptions that occur during the check</span>
            System.out.println(<span class="hljs-string">"An error occurred in canPutHorizontally: "</span> + e.getMessage());
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canPutVertically</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] c, String word, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// Check if the word can be placed vertically at position i, j on the crossword</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; word.length(); k++) {
                <span class="hljs-keyword">if</span> (i + k &lt; <span class="hljs-number">10</span> &amp;&amp; (c[i + k][j] == <span class="hljs-string">'-'</span> || c[i + k][j] == word.charAt(k))) {
                    <span class="hljs-comment">// Continue checking the next character in the word</span>
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-comment">// Return false if the word cannot be placed vertically at the current position</span>
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }
            }
            <span class="hljs-comment">// Return true if the word can be placed vertically at the given position</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-comment">// Handle any exceptions that occur during the check</span>
            System.out.println(<span class="hljs-string">"An error occurred in canPutVertically: "</span> + e.getMessage());
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] c)</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// Print the crossword grid</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span>[] cc : c) {
                <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ccc : cc) {
                    System.out.print(ccc);
                }
                System.out.println();
            }
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-comment">// Handle any exceptions that occur during printing</span>
            System.out.println(<span class="hljs-string">"An error occurred in printing: "</span> + e.getMessage());
        }
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException {
        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));
        <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bufferedWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(System.getenv(<span class="hljs-string">"OUTPUT_PATH"</span>)));

        List&lt;String&gt; crossword = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();

        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
            <span class="hljs-type">String</span> <span class="hljs-variable">crosswordItem</span> <span class="hljs-operator">=</span> bufferedReader.readLine();
            crossword.add(crosswordItem);
        }

        <span class="hljs-type">String</span> <span class="hljs-variable">words</span> <span class="hljs-operator">=</span> bufferedReader.readLine();

        List&lt;String&gt; result = Result.crosswordPuzzle(crossword, words);

        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; result.size(); i++) {
            bufferedWriter.write(result.get(i));

            <span class="hljs-keyword">if</span> (i != result.size() - <span class="hljs-number">1</span>) {
                bufferedWriter.write(<span class="hljs-string">"\n"</span>);
            }
        }

        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}</code></pre></div>
<p><strong>Sample Input</strong></p>
<pre style="background:linear-gradient(to right, #F3F7EC, white);color:#3F4E4F;padding:5px" class="jop-noMdConv">
+-++++++++
+-++++++++
+-++++++++
+-----++++
+-+++-++++
+-+++-++++
+++++-++++
++------++
+++++-++++
+++++-++++
LONDON;DELHI;ICELAND;ANKARA
</pre>
<p><strong>Sample Output</strong></p>
<pre style="background:linear-gradient(to right, #FFE6E6, white);color:#3F4E4F;padding:5px" class="jop-noMdConv">
+L++++++++
+O++++++++
+N++++++++
+DELHI++++
+O+++C++++
+N+++E++++
+++++L++++
++ANKARA++
+++++N++++
+++++D++++
</pre>
<h2 id="elucidation">Elucidation</h2>
<p>The provided code is a solution to a crossword puzzle problem. Here is a detailed explanation of each section:</p>
<ol>
<li>
<p><code>Result</code> Class:</p>
<ul>
<li>This class contains static methods to solve the crossword puzzle.</li>
<li>It initializes a static List <code>result</code> to store the solved puzzle.</li>
<li>The <code>crosswordPuzzle</code> method takes a list of strings representing the crossword grid and a string of words to place in the grid.</li>
<li>It converts the input crossword grid into a 2D char array.</li>
<li>Then, it calls the <code>helper</code> method to solve the puzzle by trying to place words horizontally and vertically.</li>
<li>If an error occurs during the solving process, it catches the exception and prints an error message.</li>
<li>The class also includes helper methods like <code>replaceHorizontal</code>, <code>replaceVertical</code>, <code>putHorizontally</code>, <code>putVertically</code>, <code>canPutHorizontally</code>, <code>canPutVertically</code>, and <code>print</code> to assist in solving the puzzle.</li>
</ul>
</li>
<li>
<p><code>Solution</code> Class:</p>
<ul>
<li>The <code>main</code> method reads input from the user to populate the crossword grid and words.</li>
<li>It then calls the <code>crosswordPuzzle</code> method from the <code>Result</code> class to solve the puzzle.</li>
<li>Finally, it writes the solved puzzle to the output file.</li>
</ul>
</li>
</ol>
<p>Overall, the code structure follows a modular approach to solving the crossword puzzle problem, with separate methods for different tasks such as checking placement validity, tracking character placement, and handling exceptions.</p>
<h2 id="the-result-class">The <code>Result</code> Class</h2>
<p>The provided code is a comprehensive solution to a crossword puzzle problem. Here is a detailed explanation of each section:</p>
<ol>
<li>
<p><code>Result</code> Class:</p>
<ul>
<li>This class contains static methods to solve the crossword puzzle.</li>
<li>It initializes a static List <code>result</code> to store the solved puzzle.</li>
<li>The <code>crosswordPuzzle</code> method takes a list of strings representing the crossword grid and a string of words to place in the grid.</li>
<li>It converts the input crossword grid into a 2D char array.</li>
<li>Then, it calls the <code>helper</code> method to solve the puzzle by trying to place words horizontally and vertically.</li>
<li>If an error occurs during the solving process, it catches the exception and prints an error message.</li>
<li>The class also includes helper methods like <code>replaceHorizontal</code>, <code>replaceVertical</code>, <code>putHorizontally</code>, <code>putVertically</code>, <code>canPutHorizontally</code>, <code>canPutVertically</code>, and <code>print</code> to assist in solving the puzzle.</li>
</ul>
</li>
<li>
<p><code>helper</code> Method:</p>
<ul>
<li>This recursive method is the core of solving the crossword puzzle.</li>
<li>It iterates through each word to be placed and tries to place it horizontally and vertically in the grid.</li>
<li>If a word can be placed, it recursively calls itself for the next word.</li>
<li>It backtracks by replacing characters if needed to explore all possible placements.</li>
</ul>
</li>
<li>
<p><code>replaceHorizontal</code> and <code>replaceVertical</code> Methods:</p>
<ul>
<li>These methods are used to backtrack and replace characters in the horizontal and vertical directions, respectively.</li>
<li>They are called when a word cannot be placed successfully.</li>
</ul>
</li>
<li>
<p><code>putHorizontally</code> and <code>putVertically</code> Methods:</p>
<ul>
<li>These methods are used to track the placement of characters for words horizontally and vertically.</li>
<li>They return a boolean array to indicate the successful placement of characters.</li>
</ul>
</li>
<li>
<p><code>canPutHorizontally</code> and <code>canPutVertically</code> Methods:</p>
<ul>
<li>These methods check if a word can be placed horizontally or vertically at a specific position in the grid.</li>
<li>They validate the placement based on the characters already present in the grid.</li>
</ul>
</li>
<li>
<p><code>print</code> Method:</p>
<ul>
<li>This method is used to print the crossword grid to the console.</li>
<li>It helps visualize the current state of the grid during the solving process.</li>
</ul>
</li>
</ol>
<p>Overall, the code structure follows a systematic approach to solving the crossword puzzle problem, with separate methods for different tasks such as checking placement validity, tracking character placement, and handling exceptions.</p>
<h2 id="the-solution-class">The <code>Solution</code> Class</h2>
<p>The provided code is the main class that reads input data, solves the crossword puzzle, and writes the solution to an output file. Here is a detailed explanation of each section:</p>
<ol>
<li>
<p><code>Solution</code> Class:</p>
<ul>
<li>This class contains the main method that serves as the entry point of the program.</li>
<li>It reads input from the user, processes the data, solves the crossword puzzle, and writes the solution to an output file.</li>
</ul>
</li>
<li>
<p><code>main</code> Method:</p>
<ul>
<li>The <code>main</code> method takes an array of strings as input arguments and throws an IOException.</li>
<li>It initializes a <code>BufferedReader</code> to read input from the console and a <code>BufferedWriter</code> to write output to a file specified in the <code>OUTPUT_PATH</code> environment variable.</li>
<li>It creates an empty list <code>crossword</code> to store the rows of the crossword grid.</li>
<li>It reads 10 lines of input representing the rows of the crossword grid and adds them to the <code>crossword</code> list.</li>
<li>It reads a single line of input containing the words to be placed in the crossword grid.</li>
<li>It calls the <code>crosswordPuzzle</code> method from the <code>Result</code> class to solve the crossword puzzle using the input grid and words.</li>
<li>It iterates through the solved puzzle (<code>result</code> list) and writes each row to the output file using the <code>BufferedWriter</code>.</li>
<li>It writes a newline character after writing each row to separate them in the output file.</li>
<li>Finally, it closes the <code>BufferedReader</code> and <code>BufferedWriter</code> to release system resources.</li>
</ul>
</li>
</ol>
<p>Overall, the <code>Solution</code> class orchestrates the process of reading input data, solving the crossword puzzle, and writing the solution to an output file. It acts as the control center of the program, coordinating the flow of data and interactions between different components.</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Code Analysis of HR Bigger is Greater problem solution]]></title>
            <guid>7821dd80a09643e4b72c2445ae89ac62</guid>
            <pubDate>Tue, 02 Jul 2024 19:23:27 GMT</pubDate>
            <content:encoded><![CDATA[<p>Given the solution code :</p>
<div><pre class="hljs"><code><span class="hljs-keyword">import</span> java.io.*;
<span class="hljs-keyword">import</span> java.math.*;
<span class="hljs-keyword">import</span> java.security.*;
<span class="hljs-keyword">import</span> java.text.*;
<span class="hljs-keyword">import</span> java.util.*;
<span class="hljs-keyword">import</span> java.util.concurrent.*;
<span class="hljs-keyword">import</span> java.util.regex.*;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Result</span> {

    <span class="hljs-comment">/*
     * Complete the 'biggerIsGreater' function below.
     *
     * The function is expected to return a STRING.
     * The function accepts STRING w as parameter.
     */</span>

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">biggerIsGreater</span><span class="hljs-params">(String w)</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-type">char</span>[] chars = w.toCharArray();
            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> chars.length - <span class="hljs-number">1</span>;

            <span class="hljs-comment">// Find the first decreasing element from the right</span>
            <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">if</span> (chars[i - <span class="hljs-number">1</span>] &gt;= chars[i]) {
                    i--;
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;

                    <span class="hljs-comment">// Find the smallest element greater than chars[i-1] from the right</span>
                    <span class="hljs-keyword">while</span> (j &lt; chars.length &amp;&amp; chars[j] &gt; chars[i - <span class="hljs-number">1</span>]) {
                        j++;
                    }

                    <span class="hljs-comment">// Swap chars[i-1] and the smallest element found</span>
                    <span class="hljs-type">char</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> chars[i - <span class="hljs-number">1</span>];
                    chars[i - <span class="hljs-number">1</span>] = chars[j - <span class="hljs-number">1</span>];
                    chars[j - <span class="hljs-number">1</span>] = temp;

                    <span class="hljs-comment">// Reverse the suffix starting from i</span>
                    reverseSuffix(chars, i);

                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chars);
                }
            }
        } <span class="hljs-keyword">catch</span> (Exception e) {
            System.out.println(<span class="hljs-string">"An error occurred: "</span> + e.getMessage());
        }

        <span class="hljs-keyword">return</span> <span class="hljs-string">"no answer"</span>;
    }
    
    <span class="hljs-comment">// Method to reverse the suffix starting from index i</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseSuffix</span><span class="hljs-params">(<span class="hljs-type">char</span>[] chars, <span class="hljs-type">int</span> i)</span> {
        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> chars.length - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (i &lt; end) {
            <span class="hljs-type">char</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> chars[i];
            chars[i] = chars[end];
            chars[end] = temp;
            i++;
            end--;
        }
    }

}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException {
        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));
        <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bufferedWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(System.getenv(<span class="hljs-string">"OUTPUT_PATH"</span>)));

        <span class="hljs-type">int</span> <span class="hljs-variable">T</span> <span class="hljs-operator">=</span> Integer.parseInt(bufferedReader.readLine().trim());

        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">TItr</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; TItr &lt; T; TItr++) {
            <span class="hljs-type">String</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> bufferedReader.readLine();

            <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Result.biggerIsGreater(w);

            bufferedWriter.write(result);
            bufferedWriter.newLine();
        }

        bufferedReader.close();
        bufferedWriter.close();
    }
}</code></pre></div>
<p><strong>Sample Input</strong></p>
<pre style="background:linear-gradient(to right, #F3F7EC, white);color:#3F4E4F;padding:5px" class="jop-noMdConv">
5
ab
bb
hefg
dhck
dkhc
</pre>
<p><strong>Sample Output</strong></p>
<pre style="background:linear-gradient(to right, #FFE6E6, white);color:#3F4E4F;padding:5px" class="jop-noMdConv">
ba
no answer
hegf
dhkc
hcdk
</pre>
<h2 id="elucidation">Elucidation</h2>
<p>Here is a detailed explanation of the provided Java code above :</p>
<ol>
<li>
<p><strong><code>Result</code> Class:</strong></p>
<ul>
<li>The <code>Result</code> class contains the <code>biggerIsGreater</code> method, which is expected to return a lexicographically greater string than the input string <code>w</code>.</li>
<li>The method follows a specific algorithm to find the next lexicographically greater permutation of the characters in the input string.</li>
</ul>
</li>
<li>
<p><strong><code>biggerIsGreater</code> Method:</strong></p>
<ul>
<li>The method processes each test case to find the next lexicographically greater string.</li>
<li>It iterates over the characters from the right to find the first decreasing element and swaps it with the smallest greater element found from the right.</li>
<li>The suffix starting from the swapped element is then reversed to get the next lexicographically greater string.</li>
</ul>
</li>
<li>
<p><strong><code>reverseSuffix</code> Method:</strong></p>
<ul>
<li>The <code>reverseSuffix</code> method reverses the suffix starting from a given index in the character array.</li>
</ul>
</li>
<li>
<p><strong><code>Solution</code> Class:</strong></p>
<ul>
<li>The <code>Solution</code> class contains the <code>main</code> method, which reads the input test cases and calls the <code>biggerIsGreater</code> method for each test case.</li>
<li>It writes the result (next lexicographically greater string) to the output file.</li>
</ul>
</li>
<li>
<p><strong>Input Processing:</strong></p>
<ul>
<li>The code reads the number of test cases (<code>T</code>) and processes each test case by reading the input string <code>w</code>.</li>
</ul>
</li>
<li>
<p><strong>Output Generation:</strong></p>
<ul>
<li>For each test case, the code calls the <code>biggerIsGreater</code> method to find the next lexicographically greater string and writes it to the output file.</li>
</ul>
</li>
<li>
<p><strong>Error Handling:</strong></p>
<ul>
<li>The code includes try-catch blocks to handle exceptions that may occur during string processing.</li>
<li>If an exception occurs, an error message is printed to the console.</li>
</ul>
</li>
<li>
<p><strong>Overall Functionality:</strong></p>
<ul>
<li>The code efficiently processes multiple test cases to find the next lexicographically greater string for each input string.</li>
<li>It follows a specific algorithm to determine the next lexicographically greater permutation of characters in the input string.</li>
</ul>
</li>
</ol>
<p>In summary, the provided Java code implements an algorithm to find the next lexicographically greater string for each test case. It demonstrates string manipulation, algorithmic logic, and input-output handling for processing multiple test cases efficiently.</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Code Analysis of HR Flipping the Matrix problem solution]]></title>
            <guid>09cd172828104c16aacc5fb5351bd8a5</guid>
            <pubDate>Tue, 02 Jul 2024 17:42:07 GMT</pubDate>
            <content:encoded><![CDATA[<p>Given the solution code :</p>
<div><pre class="hljs"><code><span class="hljs-keyword">import</span> java.io.*;
<span class="hljs-keyword">import</span> java.math.*;
<span class="hljs-keyword">import</span> java.security.*;
<span class="hljs-keyword">import</span> java.text.*;
<span class="hljs-keyword">import</span> java.util.*;
<span class="hljs-keyword">import</span> java.util.concurrent.*;
<span class="hljs-keyword">import</span> java.util.function.*;
<span class="hljs-keyword">import</span> java.util.regex.*;
<span class="hljs-keyword">import</span> java.util.stream.*;
<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.util.stream.Collectors.joining;
<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.util.stream.Collectors.toList;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Result</span> {

    <span class="hljs-comment">/*
     * Complete the 'flippingMatrix' function below.
     *
     * The function is expected to return an INTEGER.
     * The function accepts 2D_INTEGER_ARRAY matrix as parameter.
     */</span>

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">flippingMatrix</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; matrix)</span> {
        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> <span class="hljs-variable">halfMatrixSize</span> <span class="hljs-operator">=</span> matrix.size() / <span class="hljs-number">2</span>;
        <span class="hljs-type">int</span> <span class="hljs-variable">maxMatrixIndex</span> <span class="hljs-operator">=</span> matrix.size() - <span class="hljs-number">1</span>;

        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; row &lt; halfMatrixSize; row++) {
                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; col &lt; halfMatrixSize; col++) {
                    <span class="hljs-type">int</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> getElement(matrix, row, col);
                    <span class="hljs-type">int</span> <span class="hljs-variable">rightMirror</span> <span class="hljs-operator">=</span> getElement(matrix, row, maxMatrixIndex - col);
                    <span class="hljs-type">int</span> <span class="hljs-variable">downMirror</span> <span class="hljs-operator">=</span> getElement(matrix, maxMatrixIndex - row, col);
                    <span class="hljs-type">int</span> <span class="hljs-variable">rightDownMirror</span> <span class="hljs-operator">=</span> getElement(matrix, maxMatrixIndex - row, maxMatrixIndex - col);

                    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Math.max(element, Math.max(rightMirror, Math.max(downMirror, rightDownMirror)));
                    result += max;
                }
            }
        } <span class="hljs-keyword">catch</span> (Exception e) {
            System.out.println(<span class="hljs-string">"An error occurred during matrix processing: "</span> + e.getMessage());
        }

        <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">// Method to get the element at a specific row and column in the matrix</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getElement</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; matrix, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> matrix.get(row).get(col);
        } <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException e) {
            System.out.println(<span class="hljs-string">"Index out of bounds: "</span> + e.getMessage());
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// Return 0 if index is out of bounds</span>
        }
    }

}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException {
        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));
        <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bufferedWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(System.getenv(<span class="hljs-string">"OUTPUT_PATH"</span>)));

        <span class="hljs-type">int</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> Integer.parseInt(bufferedReader.readLine().trim());

        IntStream.range(<span class="hljs-number">0</span>, q).forEach(qItr -&gt; {
            <span class="hljs-keyword">try</span> {
                <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> Integer.parseInt(bufferedReader.readLine().trim());

                List&lt;List&lt;Integer&gt;&gt; matrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();

                IntStream.range(<span class="hljs-number">0</span>, <span class="hljs-number">2</span> * n).forEach(i -&gt; {
                    <span class="hljs-keyword">try</span> {
                        matrix.add(
                            Stream.of(bufferedReader.readLine().replaceAll(<span class="hljs-string">"\\s+$"</span>, <span class="hljs-string">""</span>).split(<span class="hljs-string">" "</span>))
                                .map(Integer::parseInt)
                                .collect(toList())
                        );
                    } <span class="hljs-keyword">catch</span> (IOException ex) {
                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(ex);
                    }
                });

                <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Result.flippingMatrix(matrix);

                bufferedWriter.write(String.valueOf(result));
                bufferedWriter.newLine();
            } <span class="hljs-keyword">catch</span> (IOException ex) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(ex);
            }
        });

        bufferedReader.close();
        bufferedWriter.close();
    }
}</code></pre></div>
<p><strong>Sample Input</strong></p>
<pre style="background:linear-gradient(to right, #F3F7EC, white);color:#3F4E4F;padding:5px" class="jop-noMdConv">
1               
2               
112 42 83 119   
56 125 56 49             
15 78 101 43
62 98 114 108
</pre>
<p><strong>Sample Output</strong></p>
<pre style="background:linear-gradient(to right, #FFE6E6, white);color:#3F4E4F;padding:5px" class="jop-noMdConv">
414
</pre>
<h2 id="elucidation">Elucidation</h2>
<p>The provided code consists of two classes: <code>Result</code> and <code>Solution</code>. Here is a detailed explanation of the code:</p>
<ol>
<li>
<p><strong><code>Result</code> Class:</strong></p>
<ul>
<li>The <code>Result</code> class contains the <code>flippingMatrix</code> method, which calculates the maximum sum possible for the upper-left quadrant of a matrix after flipping rows and columns.</li>
<li>The method takes a 2D list of integers (<code>List&lt;List&lt;Integer&gt;&gt;</code>) as a parameter and iterates over the matrix to calculate the maximum sum.</li>
</ul>
</li>
<li>
<p><strong><code>Solution</code> Class:</strong></p>
<ul>
<li>The <code>Solution</code> class contains the <code>main</code> method, which is the entry point of the program.</li>
<li>It reads input from the user, processes each query, and calculates the maximum sum using the <code>flippingMatrix</code> method from the <code>Result</code> class.</li>
<li>The input format includes the number of queries (<code>q</code>) followed by the size of the matrix (<code>n</code>) and the elements of the matrix.</li>
</ul>
</li>
<li>
<p><strong>Input Processing:</strong></p>
<ul>
<li>The <code>main</code> method reads the number of queries (<code>q</code>) and processes each query individually.</li>
<li>For each query, it reads the size of the matrix (<code>n</code>) and populates the matrix with elements provided by the user.</li>
</ul>
</li>
<li>
<p><strong>Matrix Processing:</strong></p>
<ul>
<li>The matrix elements are read and stored in a 2D list of integers.</li>
<li>The <code>flippingMatrix</code> method is called for each query to calculate the maximum sum for the upper-left quadrant of the matrix.</li>
</ul>
</li>
<li>
<p><strong>Error Handling:</strong></p>
<ul>
<li>The code includes try-catch blocks to handle exceptions that may occur during matrix processing or input reading.</li>
<li>If an exception occurs, an error message is printed to the console.</li>
</ul>
</li>
<li>
<p><strong>Output:</strong></p>
<ul>
<li>The calculated maximum sum for each query is written to the output file.</li>
</ul>
</li>
<li>
<p><strong>Overall Functionality:</strong></p>
<ul>
<li>The code efficiently processes multiple queries to calculate the maximum sum for the upper-left quadrant of matrices after flipping rows and columns.</li>
<li>Error handling ensures that exceptions are caught and appropriate messages are displayed.</li>
</ul>
</li>
</ol>
<p>In summary, the code provides a structured solution for processing matrices and calculating the maximum sum for the upper-left quadrant. It demonstrates input processing, matrix manipulation, error handling, and output generation.</p>
<h2 id="flippingmatrix-method"><code>flippingMatrix</code> Method</h2>
<p>Here is a detailed analysis of the provided Java method:</p>
<ol>
<li>
<p><strong><code>flippingMatrix</code> Method:</strong></p>
<ul>
<li>The <code>flippingMatrix</code> method calculates the maximum sum possible for the upper-left quadrant of a given matrix after flipping rows and columns.</li>
<li>It iterates over the top-left quadrant of the matrix and calculates the maximum value for each element and adds it to the result.</li>
<li>If an exception occurs during matrix processing (such as an index out of bounds), an error message is displayed.</li>
</ul>
</li>
<li>
<p><strong>Variables:</strong></p>
<ul>
<li><code>result</code>: Stores the sum of the maximum values in the upper-left quadrant.</li>
<li><code>halfMatrixSize</code>: Represents half the size of the matrix (used to iterate over the top-left quadrant).</li>
<li><code>maxMatrixIndex</code>: Represents the maximum index of the matrix.</li>
</ul>
</li>
<li>
<p><strong>Nested Loops:</strong></p>
<ul>
<li>Two nested loops iterate over the top-left quadrant of the matrix (up to <code>halfMatrixSize</code>).</li>
<li>For each element in the quadrant, it calculates the maximum value among the element, its right mirror, down mirror, and right-down mirror.</li>
</ul>
</li>
<li>
<p><strong><code>getElement</code> Method:</strong></p>
<ul>
<li>The <code>getElement</code> method retrieves the element at a specific row and column in the matrix.</li>
<li>It handles potential <code>IndexOutOfBoundsException</code> by catching the exception and returning 0 if the index is out of bounds.</li>
</ul>
</li>
<li>
<p><strong>Error Handling:</strong></p>
<ul>
<li>The code uses a try-catch block to catch exceptions that may occur during matrix processing.</li>
<li>If an exception occurs, an error message is printed to the console.</li>
</ul>
</li>
<li>
<p><strong>Return Value:</strong></p>
<ul>
<li>The method returns the calculated <code>result</code>, which represents the maximum sum in the upper-left quadrant after flipping rows and columns.</li>
</ul>
</li>
<li>
<p><strong>Overall Functionality:</strong></p>
<ul>
<li>The code efficiently processes the matrix to calculate the maximum sum for the upper-left quadrant.</li>
<li>It includes error handling to handle index out of bounds situations and ensures that the output is accurate.</li>
</ul>
</li>
</ol>
<p>In summary, the provided Java code effectively calculates the maximum sum for the upper-left quadrant of a matrix after flipping rows and columns, with error handling to address potential exceptions.</p>
<h2 id="flippingmatrix-method-alternative"><code>flippingMatrix</code> Method Alternative</h2>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">flippingMatrix</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; matrix)</span> {
    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
    <span class="hljs-type">int</span> <span class="hljs-variable">halfMatrixSize</span> <span class="hljs-operator">=</span> matrix.size() / <span class="hljs-number">2</span>;
    <span class="hljs-type">int</span> <span class="hljs-variable">maxMatrixIndex</span> <span class="hljs-operator">=</span> matrix.size() - <span class="hljs-number">1</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; row &lt; halfMatrixSize; row++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; col &lt; halfMatrixSize; col++) {
            <span class="hljs-type">int</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> matrix.get(row).get(col);
            <span class="hljs-type">int</span> <span class="hljs-variable">rightMirror</span> <span class="hljs-operator">=</span> matrix.get(row).get(maxMatrixIndex - col);
            <span class="hljs-type">int</span> <span class="hljs-variable">downMirror</span> <span class="hljs-operator">=</span> matrix.get(maxMatrixIndex - row).get(col);
            <span class="hljs-type">int</span> <span class="hljs-variable">rightDownMirror</span> <span class="hljs-operator">=</span> matrix.get(maxMatrixIndex - row).get(maxMatrixIndex - col);

            <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Math.max(Math.max(element, rightMirror), Math.max(downMirror, rightDownMirror));
            result += max;
        }
    }
    <span class="hljs-keyword">return</span> result;
}</code></pre></div>
<p>Detailed explanation of the provided Java code above :</p>
<ol>
<li>
<p><strong>Method Overview:</strong></p>
<ul>
<li>The <code>flippingMatrix</code> method calculates the maximum sum possible for the upper-left quadrant of a given matrix after flipping rows and columns.</li>
<li>It iterates over the top-left quadrant of the matrix and calculates the maximum value for each element, summing up the maximum values.</li>
</ul>
</li>
<li>
<p><strong>Variables:</strong></p>
<ul>
<li><code>result</code>: Initialized to 0, stores the sum of the maximum values in the upper-left quadrant.</li>
<li><code>halfMatrixSize</code>: Represents half the size of the matrix, used to iterate over the top-left quadrant.</li>
<li><code>maxMatrixIndex</code>: Represents the maximum index of the matrix.</li>
</ul>
</li>
<li>
<p><strong>Nested Loops:</strong></p>
<ul>
<li>Two nested loops iterate over the top-left quadrant of the matrix (up to <code>halfMatrixSize</code>).</li>
<li>For each element in the quadrant, it calculates the maximum value among the element, its mirror on the right, down mirror, and right-down mirror.</li>
</ul>
</li>
<li>
<p><strong>Matrix Element Retrieval:</strong></p>
<ul>
<li><code>element</code>: Retrieves the element at the current row and column.</li>
<li><code>rightMirror</code>: Retrieves the mirror element on the right side of the current column.</li>
<li><code>downMirror</code>: Retrieves the mirror element below the current row.</li>
<li><code>rightDownMirror</code>: Retrieves the mirror element diagonally opposite to the current element.</li>
</ul>
</li>
<li>
<p><strong>Maximum Value Calculation:</strong></p>
<ul>
<li>For each element in the quadrant, it calculates the maximum value among the element, right mirror, down mirror, and right-down mirror.</li>
<li>The maximum value is added to the <code>result</code> for each iteration of the nested loops.</li>
</ul>
</li>
<li>
<p><strong>Return Value:</strong></p>
<ul>
<li>The method returns the calculated <code>result</code>, representing the maximum sum in the upper-left quadrant after flipping rows and columns.</li>
</ul>
</li>
<li>
<p><strong>Overall Functionality:</strong></p>
<ul>
<li>The code efficiently processes the matrix to calculate the maximum sum for the upper-left quadrant.</li>
<li>It iterates over the quadrant, considers mirrored elements, calculates the maximum value, and sums up the maximum values to determine the final result.</li>
</ul>
</li>
</ol>
<p>In summary, the provided Java code effectively calculates the maximum sum for the upper-left quadrant of a matrix after flipping rows and columns. It demonstrates efficient matrix processing and maximum value calculation within the specified quadrant.</p>
<hr />
<h2 id="list-interface"><code>List</code> Interface</h2>
<ol>
<li>
<p><strong>List Interface in Java:</strong></p>
<ul>
<li>The <code>List</code> interface in Java is a part of the <code>java.util</code> package and extends the <code>Collection</code> interface.</li>
<li>It represents an ordered collection of elements where each element has an index.</li>
<li>Lists allow duplicate elements and maintain the insertion order of elements.</li>
</ul>
</li>
<li>
<p><strong>Key Features of List:</strong></p>
<ul>
<li>Elements in a list can be accessed using their index.</li>
<li>Lists provide methods to add, remove, retrieve, and manipulate elements.</li>
<li>Common implementations of the <code>List</code> interface in Java include <code>ArrayList</code>, <code>LinkedList</code>, and <code>Vector</code>.</li>
</ul>
</li>
<li>
<p><strong>Code Example:</strong></p>
</li>
</ol>
<div><pre class="hljs"><code><span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListExample</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// Creating a List of Strings</span>
        List&lt;String&gt; fruits = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();

        <span class="hljs-comment">// Adding elements to the list</span>
        fruits.add(<span class="hljs-string">"Apple"</span>);
        fruits.add(<span class="hljs-string">"Banana"</span>);
        fruits.add(<span class="hljs-string">"Orange"</span>);
        fruits.add(<span class="hljs-string">"Mango"</span>);

        <span class="hljs-comment">// Accessing elements in the list</span>
        System.out.println(<span class="hljs-string">"Fruits List: "</span> + fruits);

        <span class="hljs-comment">// Getting the size of the list</span>
        System.out.println(<span class="hljs-string">"Size of the List: "</span> + fruits.size());

        <span class="hljs-comment">// Removing an element</span>
        fruits.remove(<span class="hljs-string">"Orange"</span>);

        <span class="hljs-comment">// Checking if an element exists</span>
        System.out.println(<span class="hljs-string">"Contains 'Banana': "</span> + fruits.contains(<span class="hljs-string">"Banana"</span>));

        <span class="hljs-comment">// Iterating over the list</span>
        System.out.println(<span class="hljs-string">"Iterating over the List:"</span>);
        <span class="hljs-keyword">for</span> (String fruit : fruits) {
            System.out.println(fruit);
        }
    }
}</code></pre></div>
<ol start="4">
<li>
<p><strong>Output Explanation:</strong></p>
<ul>
<li>The code example creates a list of fruits, adds elements, removes an element, and demonstrates various operations on the list.</li>
<li>The output displays the fruits list, size of the list, checks if an element exists, and iterates over the list to print each element.</li>
</ul>
</li>
<li>
<p><strong>Output:</strong></p>
</li>
</ol>
<div><pre class="hljs"><code><span class="hljs-attr">Fruits List:</span> [<span class="hljs-string">Apple</span>, <span class="hljs-string">Banana</span>, <span class="hljs-string">Orange</span>, <span class="hljs-string">Mango</span>]
<span class="hljs-attr">Size of the List:</span> <span class="hljs-number">4</span>
<span class="hljs-string">Contains</span> <span class="hljs-attr">'Banana':</span> <span class="hljs-literal">true</span>
<span class="hljs-attr">Iterating over the List:</span>
<span class="hljs-string">Apple</span>
<span class="hljs-string">Banana</span>
<span class="hljs-string">Mango</span></code></pre></div>
<ol start="6">
<li><strong>Summary:</strong>
<ul>
<li>The <code>List</code> interface in Java provides an ordered collection of elements with index-based access.</li>
<li>It supports operations like adding, removing, retrieving elements, and more.</li>
<li>Lists are versatile data structures commonly used in Java programming for managing collections of objects.</li>
</ul>
</li>
</ol>
<p>In summary, the <code>List</code> interface in Java offers a flexible and powerful way to work with ordered collections of elements. It provides a wide range of methods for managing and manipulating lists efficiently.</p>
<hr />
<h2 id="listlistinteger-matrix-parameter"><code>List&lt;List&lt;Integer&gt;&gt; matrix</code> Parameter</h2>
<p>The line of Java code <code>List&lt;List&lt;Integer&gt;&gt; matrix</code> declares a 2D list of integers in Java.</p>
<ol>
<li>
<p><strong>Explanation:</strong></p>
<ul>
<li><code>List&lt;List&lt;Integer&gt;&gt;</code>: This declares a 2D list where each element in the outer list (<code>List&lt;List&lt;Integer&gt;&gt;</code>) is itself a list of integers (<code>List&lt;Integer&gt;</code>).</li>
<li>This structure represents a matrix where each row is represented as an inner list of integers, and the entire matrix is a list of rows.</li>
</ul>
</li>
<li>
<p><strong>Code Example:</strong></p>
</li>
</ol>
<div><pre class="hljs"><code><span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MatrixExample</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// Creating a 2D list (matrix) of integers</span>
        List&lt;List&lt;Integer&gt;&gt; matrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();

        <span class="hljs-comment">// Adding rows to the matrix</span>
        matrix.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(List.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)));
        matrix.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(List.of(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)));
        matrix.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(List.of(<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>)));

        <span class="hljs-comment">// Accessing elements in the matrix</span>
        System.out.println(<span class="hljs-string">"Matrix: "</span>);
        <span class="hljs-keyword">for</span> (List&lt;Integer&gt; row : matrix) {
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : row) {
                System.out.print(num + <span class="hljs-string">" "</span>);
            }
            System.out.println();
        }
    }
}</code></pre></div>
<ol start="3">
<li>
<p><strong>Output Explanation:</strong></p>
<ul>
<li>The code example creates a 2D list (matrix) of integers, adds rows to the matrix, and then iterates over the matrix to print each element.</li>
<li>The output displays the matrix with rows and elements separated by spaces.</li>
</ul>
</li>
<li>
<p><strong>Output:</strong></p>
</li>
</ol>
<div><pre class="hljs"><code><span class="hljs-attribute">Matrix</span>:
<span class="hljs-attribute">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> 
<span class="hljs-attribute">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> 
<span class="hljs-attribute">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> </code></pre></div>
<ol start="5">
<li><strong>Summary:</strong>
<ul>
<li>The line <code>List&lt;List&lt;Integer&gt;&gt; matrix</code> declares a 2D list of integers in Java, representing a matrix structure.</li>
<li>Each inner list represents a row of the matrix, and the outer list holds all the rows of the matrix.</li>
<li>This structure is commonly used to represent tabular data, matrices, or grids in Java programming.</li>
</ul>
</li>
</ol>
<p>In summary, the Java code <code>List&lt;List&lt;Integer&gt;&gt; matrix</code> declares a 2D list of integers, providing a flexible way to work with matrix-like data structures. The code example demonstrates creating and accessing elements in a 2D list, showcasing the matrix structure.</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Code Analysis of HR Sherlock and Anagrams problem solution]]></title>
            <guid>2107657484a54bd689b379c39e69961c</guid>
            <pubDate>Tue, 02 Jul 2024 06:55:39 GMT</pubDate>
            <content:encoded><![CDATA[<p>Given the solution code :</p>
<div><pre class="hljs"><code><span class="hljs-keyword">import</span> java.io.*;
<span class="hljs-keyword">import</span> java.math.*;
<span class="hljs-keyword">import</span> java.security.*;
<span class="hljs-keyword">import</span> java.text.*;
<span class="hljs-keyword">import</span> java.util.*;
<span class="hljs-keyword">import</span> java.util.concurrent.*;
<span class="hljs-keyword">import</span> java.util.regex.*;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Result</span> {

    <span class="hljs-comment">/*
     * Complete the 'sherlockAndAnagrams' function below.
     *
     * The function is expected to return an INTEGER.
     * The function accepts STRING s as parameter.
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sherlockAndAnagrams</span><span class="hljs-params">(String s)</span> {
        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
        Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();

        <span class="hljs-comment">// Generate all possible substrings and count the occurrences of each substring</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt;= s.length(); j++) {
                <span class="hljs-type">String</span> <span class="hljs-variable">currentSub</span> <span class="hljs-operator">=</span> s.substring(i, j);
                <span class="hljs-type">String</span> <span class="hljs-variable">sortedSub</span> <span class="hljs-operator">=</span> sortString(currentSub);

                <span class="hljs-keyword">if</span> (map.containsKey(sortedSub)) {
                    count += map.get(sortedSub);
                    map.put(sortedSub, map.get(sortedSub) + <span class="hljs-number">1</span>);
                } <span class="hljs-keyword">else</span> {
                    map.put(sortedSub, <span class="hljs-number">1</span>);
                }
            }
        }

        <span class="hljs-keyword">return</span> count;
    }

    <span class="hljs-comment">// Helper method to sort a string</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">sortString</span><span class="hljs-params">(String str)</span> {
        <span class="hljs-type">char</span>[] charArray = str.toCharArray();
        Arrays.sort(charArray);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(charArray);
    }

}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException {
        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));
        <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bufferedWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(System.getenv(<span class="hljs-string">"OUTPUT_PATH"</span>)));

        <span class="hljs-type">int</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> Integer.parseInt(bufferedReader.readLine().trim());

        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">qItr</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; qItr &lt; q; qItr++) {
            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> bufferedReader.readLine();

            <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Result.sherlockAndAnagrams(s);

            bufferedWriter.write(String.valueOf(result));
            bufferedWriter.newLine();
        }

        bufferedReader.close();
        bufferedWriter.close();
    }
}</code></pre></div>
<p><strong>Sample Input</strong></p>
<pre style="background:linear-gradient(to right, #F3F7EC, white);color:#3F4E4F;padding:5px" class="jop-noMdConv">
2
abba
abcd
</pre>
<p><strong>Sample Output</strong></p>
<pre style="background:linear-gradient(to right, #FFE6E6, white);color:#3F4E4F;padding:5px" class="jop-noMdConv">
4
0
</pre>
<h2 id="elucidation">Elucidation</h2>
<p>Explanation of the provided Java code above:</p>
<ol>
<li>
<p><strong><code>Result</code> Class:</strong></p>
<ul>
<li>Contains the <code>sherlockAndAnagrams</code> method that calculates the number of anagrammatic pairs of substrings in the given string <code>s</code>.</li>
<li>It uses a <code>HashMap</code> to store the sorted substrings and their occurrences for counting anagram pairs.</li>
<li>The method generates all possible substrings of <code>s</code>, sorts each substring, and counts the occurrences of anagrams.</li>
</ul>
</li>
<li>
<p><strong><code>sortString</code> Method:</strong></p>
<ul>
<li>Private helper method in the <code>Result</code> class to sort the characters of a string.</li>
<li>Used to sort each substring before storing it in the map for accurate comparison of anagrams.</li>
</ul>
</li>
<li>
<p><strong><code>Solution</code> Class:</strong></p>
<ul>
<li>Contains the <code>main</code> method that reads input from the user, calls the <code>sherlockAndAnagrams</code> method, and writes the results to an output file.</li>
<li>Reads the number of queries <code>q</code>, followed by <code>q</code> strings <code>s</code> to analyze for anagram pairs.</li>
<li>For each query, it calculates the number of anagram pairs using the <code>sherlockAndAnagrams</code> method and writes the result to the output file.</li>
</ul>
</li>
<li>
<p><strong>Execution Flow:</strong></p>
<ul>
<li>The <code>main</code> method reads the input queries and strings from the user.</li>
<li>For each input string, it calls the <code>sherlockAndAnagrams</code> method to calculate the number of anagram pairs.</li>
<li>The result for each query is written to the output file.</li>
</ul>
</li>
<li>
<p><strong>Input and Output Handling:</strong></p>
<ul>
<li>Input: Reads the number of queries <code>q</code> and <code>q</code> strings from the user.</li>
<li>Output: Writes the number of anagram pairs for each query to an output file.</li>
</ul>
</li>
<li>
<p><strong>Overall Functionality:</strong></p>
<ul>
<li>The code efficiently calculates the number of anagrammatic pairs of substrings in the given strings by sorting substrings and using a HashMap for counting occurrences.</li>
<li>It handles input and output operations to process multiple queries and strings to determine anagram pairs.</li>
</ul>
</li>
</ol>
<p>The provided code demonstrates a well-structured solution for finding anagram pairs in strings and efficiently handles input/output operations.</p>
<hr />
<h2 id="hashmap-class"><code>HashMap</code> Class</h2>
<h3 id="hashmap-class-in-java">HashMap Class in Java:</h3>
<ol>
<li>
<p><strong>Definition</strong>:</p>
<ul>
<li><code>HashMap</code> is a class in Java that implements the <code>Map</code> interface to store key-value pairs.</li>
<li>It allows null keys and values, and it does not maintain the order of elements.</li>
</ul>
</li>
<li>
<p><strong>Key Features</strong>:</p>
<ul>
<li><strong>Fast Lookup</strong>: HashMap provides constant-time performance for basic operations like get and put.</li>
<li><strong>Key-Value Pairs</strong>: Each entry in a HashMap is a key-value pair.</li>
<li><strong>Resizable</strong>: HashMap automatically resizes itself when the number of elements exceeds a certain threshold.</li>
<li><strong>Thread-Safe</strong>: HashMap is not synchronized by default. If thread safety is required, you can use <code>Collections.synchronizedMap()</code>.</li>
</ul>
</li>
<li>
<p><strong>Common Methods</strong>:</p>
<ul>
<li><code>put(key, value)</code>: Inserts a key-value pair into the HashMap.</li>
<li><code>get(key)</code>: Retrieves the value associated with the specified key.</li>
<li><code>containsKey(key)</code>: Checks if the HashMap contains a specific key.</li>
<li><code>keySet()</code>: Returns a Set containing all the keys in the HashMap.</li>
<li><code>values()</code>: Returns a Collection containing all the values in the HashMap.</li>
<li><code>remove(key)</code>: Removes the key-value pair associated with the specified key.</li>
</ul>
</li>
<li>
<p><strong>Code Example</strong>:</p>
<div><pre class="hljs"><code><span class="hljs-keyword">import</span> java.util.HashMap;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashMapExample</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// Create a new HashMap</span>
        HashMap&lt;String, Integer&gt; scores = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();

        <span class="hljs-comment">// Add key-value pairs to the HashMap</span>
        scores.put(<span class="hljs-string">"Alice"</span>, <span class="hljs-number">95</span>);
        scores.put(<span class="hljs-string">"Bob"</span>, <span class="hljs-number">85</span>);
        scores.put(<span class="hljs-string">"Charlie"</span>, <span class="hljs-number">90</span>);

        <span class="hljs-comment">// Retrieve and print the value for a specific key</span>
        System.out.println(<span class="hljs-string">"Bob's score: "</span> + scores.get(<span class="hljs-string">"Bob"</span>));

        <span class="hljs-comment">// Check if a key exists in the HashMap</span>
        <span class="hljs-keyword">if</span> (scores.containsKey(<span class="hljs-string">"Alice"</span>)) {
            System.out.println(<span class="hljs-string">"Alice's score is present."</span>);
        }

        <span class="hljs-comment">// Remove a key-value pair from the HashMap</span>
        scores.remove(<span class="hljs-string">"Charlie"</span>);

        <span class="hljs-comment">// Iterate over the keys and values in the HashMap</span>
        <span class="hljs-keyword">for</span> (String name : scores.keySet()) {
            System.out.println(name + <span class="hljs-string">"'s score: "</span> + scores.get(name));
        }
    }
}</code></pre></div>
</li>
<li>
<p><strong>Output</strong>:</p>
<div><pre class="hljs"><code>Bob<span class="hljs-string">'s score: 85
Alice'</span>s score <span class="hljs-keyword">is</span> present.
Alic<span class="hljs-string">e's score: 95
Bob'</span>s score: <span class="hljs-number">85</span></code></pre></div>
</li>
<li>
<p><strong>Explanation</strong>:</p>
<ul>
<li>In the code example, we create a HashMap named <code>scores</code> that stores String keys and Integer values.</li>
<li>We add key-value pairs representing names and scores to the HashMap using the <code>put</code> method.</li>
<li>We retrieve and print Bob’s score using the <code>get</code> method.</li>
<li>We check if Alice’s score is present in the HashMap using <code>containsKey</code>.</li>
<li>We remove Charlie’s score from the HashMap using <code>remove</code>.</li>
<li>Finally, we iterate over the keys in the HashMap using <code>keySet</code> and print each name along with their score.</li>
</ul>
</li>
</ol>
<p>This example demonstrates the basic usage of the HashMap class in Java for storing and manipulating key-value pairs. The output shows the retrieved values and messages based on the operations performed on the HashMap.</p>
<hr />
<h2 id="string-class"><code>String</code> Class</h2>
<p>The <code>String</code> class in Java is a fundamental class that represents a sequence of characters. It is widely used for storing and manipulating textual data. Here is a detailed explanation, along with a code example and its output, showcasing the features of the <code>String</code> class in Java:</p>
<ol>
<li>
<p><strong>Explanation:</strong></p>
<ul>
<li>The <code>String</code> class in Java is immutable, meaning that once a <code>String</code> object is created, its value cannot be changed.</li>
<li>Strings in Java are zero-indexed, where the first character is at index 0, the second character is at index 1, and so on.</li>
<li>The <code>String</code> class provides a wide range of methods for various string operations, such as concatenation, comparison, extraction, and manipulation.</li>
</ul>
</li>
<li>
<p><strong>Code Example:</strong></p>
</li>
</ol>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringExample</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// Creating String objects</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">"Hello, "</span>;
        <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">"World!"</span>;
        
        <span class="hljs-comment">// Concatenating strings</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> str1 + str2;
        
        <span class="hljs-comment">// Getting the length of a string</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> result.length();
        
        <span class="hljs-comment">// Extracting a substring</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">sub</span> <span class="hljs-operator">=</span> result.substring(<span class="hljs-number">7</span>);
        
        <span class="hljs-comment">// Checking if a string contains a specific character sequence</span>
        <span class="hljs-type">boolean</span> <span class="hljs-variable">contains</span> <span class="hljs-operator">=</span> result.contains(<span class="hljs-string">"World"</span>);
        
        <span class="hljs-comment">// Converting a string to uppercase</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">upperCase</span> <span class="hljs-operator">=</span> result.toUpperCase();
        
        <span class="hljs-comment">// Displaying the results</span>
        System.out.println(<span class="hljs-string">"Concatenated String: "</span> + result);
        System.out.println(<span class="hljs-string">"Length of String: "</span> + length);
        System.out.println(<span class="hljs-string">"Substring: "</span> + sub);
        System.out.println(<span class="hljs-string">"Contains 'World': "</span> + contains);
        System.out.println(<span class="hljs-string">"Uppercase String: "</span> + upperCase);
    }
}</code></pre></div>
<ol start="3">
<li>
<p><strong>Output Explanation:</strong></p>
<ul>
<li>The code example demonstrates various operations using the <code>String</code> class:
<ul>
<li>Concatenation of two strings.</li>
<li>Retrieving the length of the concatenated string.</li>
<li>Extracting a substring starting from index 7.</li>
<li>Checking if the string contains a specific sequence.</li>
<li>Converting the string to uppercase.</li>
</ul>
</li>
<li>Each operation showcases a different method provided by the <code>String</code> class.</li>
</ul>
</li>
<li>
<p><strong>Output:</strong></p>
</li>
</ol>
<div><pre class="hljs"><code><span class="hljs-attr">Concatenated String:</span> <span class="hljs-string">Hello,</span> <span class="hljs-string">World!</span>
<span class="hljs-attr">Length of String:</span> <span class="hljs-number">13</span>
<span class="hljs-attr">Substring:</span> <span class="hljs-string">World!</span>
<span class="hljs-string">Contains</span> <span class="hljs-attr">'World':</span> <span class="hljs-literal">true</span>
<span class="hljs-attr">Uppercase String:</span> <span class="hljs-string">HELLO,</span> <span class="hljs-string">WORLD!</span></code></pre></div>
<ol start="5">
<li><strong>Summary:</strong>
<ul>
<li>The <code>String</code> class in Java provides a wide range of methods for string manipulation and processing.</li>
<li>It is immutable, efficient, and widely used for storing and working with textual data.</li>
<li>By utilizing various methods of the <code>String</code> class, developers can perform common string operations effectively.</li>
</ul>
</li>
</ol>
<p>In summary, the <code>String</code> class in Java is a versatile and essential class for working with text data. It offers a rich set of methods for string manipulation, making it a powerful tool for handling textual information in Java programs.</p>
<hr />
<h2 id="method-of-java-string-class">Method of Java <code>String</code> Class</h2>
<p>The <code>String</code> class in Java provides many methods for various string operations. As of Java 16, the <code>String</code> class has a total of 78 public methods. These methods cover a wide range of functionalities, including string manipulation, comparison, searching, extraction, modification, and more.</p>
<p>Here are some common categories of methods found in the <code>String</code> class:</p>
<ol>
<li>
<p><strong>Basic Operations:</strong></p>
<ul>
<li><code>length()</code>: Returns the length of the string.</li>
<li><code>charAt(int index)</code>: Returns the character at the specified index.</li>
<li><code>substring(int beginIndex)</code>: Returns a substring starting from the specified index.</li>
<li><code>substring(int beginIndex, int endIndex)</code>: Returns a substring within the specified range.</li>
</ul>
</li>
<li>
<p><strong>Comparison and Searching:</strong></p>
<ul>
<li><code>equals(Object obj)</code>: Compares the string with the specified object for equality.</li>
<li><code>equalsIgnoreCase(String anotherString)</code>: Compares the string with another string, ignoring case.</li>
<li><code>indexOf(String str)</code>: Returns the index of the first occurrence of a substring.</li>
<li><code>contains(CharSequence s)</code>: Checks if the string contains a specified sequence.</li>
</ul>
</li>
<li>
<p><strong>Modification and Concatenation:</strong></p>
<ul>
<li><code>concat(String str)</code>: Concatenates the specified string to the end of the current string.</li>
<li><code>replace(char oldChar, char newChar)</code>: Replaces all occurrences of a character with another character.</li>
<li><code>toUpperCase()</code>: Converts the string to uppercase.</li>
<li><code>toLowerCase()</code>: Converts the string to lowercase.</li>
<li><code>trim()</code>: Removes leading and trailing whitespace.</li>
</ul>
</li>
<li>
<p><strong>Conversion and Splitting:</strong></p>
<ul>
<li><code>valueOf(int i)</code>: Converts an integer to a string.</li>
<li><code>toCharArray()</code>: Converts the string to a character array.</li>
<li><code>split(String regex)</code>: Splits the string into an array of substrings based on a regular expression.</li>
</ul>
</li>
</ol>
<p>These are just a few examples of the methods available in the <code>String</code> class. The comprehensive list of methods provides a wide range of functionalities for working with strings in Java.</p>
<hr />
<h2 id="stringlength-method"><code>String.length()</code> Method</h2>
<ol>
<li>
<p><strong>Explanation:</strong></p>
<ul>
<li>The <code>length()</code> method in Java is a built-in method of the <code>String</code> class that returns the length of the string, i.e., the number of characters in the string.</li>
<li>The length of a string includes all characters, including spaces, special characters, and digits.</li>
<li>The index of the last character in a string is always one less than the length of the string due to zero-based indexing.</li>
</ul>
</li>
<li>
<p><strong>Code Example:</strong></p>
</li>
</ol>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringLengthExample</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">"Hello, World!"</span>;
        <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">"Java is fun"</span>;
        
        <span class="hljs-type">int</span> <span class="hljs-variable">length1</span> <span class="hljs-operator">=</span> str1.length();
        <span class="hljs-type">int</span> <span class="hljs-variable">length2</span> <span class="hljs-operator">=</span> str2.length();
        
        System.out.println(<span class="hljs-string">"Length of \""</span> + str1 + <span class="hljs-string">"\": "</span> + length1);
        System.out.println(<span class="hljs-string">"Length of \""</span> + str2 + <span class="hljs-string">"\": "</span> + length2);
    }
}</code></pre></div>
<ol start="3">
<li>
<p><strong>Output Explanation:</strong></p>
<ul>
<li>In the code example, two strings <code>str1</code> and <code>str2</code> are defined with different lengths.</li>
<li>The <code>length()</code> method is called on each string to get the length, and the results are printed.</li>
<li>The output will display the lengths of the two strings, which are the number of characters in each string.</li>
</ul>
</li>
<li>
<p><strong>Output:</strong></p>
</li>
</ol>
<div><pre class="hljs"><code><span class="hljs-attribute">Length</span> of <span class="hljs-string">"Hello, World!"</span>: <span class="hljs-number">13</span>
<span class="hljs-attribute">Length</span> of <span class="hljs-string">"Java is fun"</span>: <span class="hljs-number">11</span></code></pre></div>
<ol start="5">
<li><strong>Summary:</strong>
<ul>
<li>The <code>length()</code> method in Java returns the number of characters in a string.</li>
<li>It is a useful method for determining the size of a string and performing operations based on the length of the string.</li>
<li>The output of the <code>length()</code> method is an integer representing the length of the string.</li>
</ul>
</li>
</ol>
<p>In summary, the <code>String.length()</code> method in Java provides a simple and effective way to determine the length of a string. It is commonly used in various string manipulation tasks to handle and process strings of different lengths.</p>
<hr />
<h2 id="stringsubstring-method"><code>String.substring()</code> Method</h2>
<ol>
<li>
<p><strong>Explanation:</strong></p>
<ul>
<li>The <code>substring()</code> method in Java is a built-in method of the <code>String</code> class used to extract a substring from a given string.</li>
<li>It takes one or two parameters: the starting index (inclusive) and the optional ending index (exclusive) of the substring.</li>
<li>If only one parameter is provided, the substring starting from the specified index to the end of the string is returned.</li>
</ul>
</li>
<li>
<p><strong>Code Example:</strong></p>
</li>
</ol>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubstringExample</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">"Hello, World!"</span>;
        
        <span class="hljs-type">String</span> <span class="hljs-variable">sub1</span> <span class="hljs-operator">=</span> str.substring(<span class="hljs-number">7</span>); <span class="hljs-comment">// Starting from index 7 to the end</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">sub2</span> <span class="hljs-operator">=</span> str.substring(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// From index 0 to 5 (exclusive)</span>
        
        System.out.println(<span class="hljs-string">"Substring 1: "</span> + sub1);
        System.out.println(<span class="hljs-string">"Substring 2: "</span> + sub2);
    }
}</code></pre></div>
<ol start="3">
<li>
<p><strong>Output Explanation:</strong></p>
<ul>
<li>In the code example, a string <code>str</code> is defined as “Hello, World!”.</li>
<li>The <code>substring()</code> method is called with different parameters to extract substrings.</li>
<li><code>sub1</code> extracts the substring starting from index 7 to the end of the string.</li>
<li><code>sub2</code> extracts the substring from index 0 to 5 (excluding the character at index 5).</li>
</ul>
</li>
<li>
<p><strong>Output:</strong></p>
</li>
</ol>
<div><pre class="hljs"><code><span class="hljs-attribute">Substring</span> <span class="hljs-number">1</span>: World!
<span class="hljs-attribute">Substring</span> <span class="hljs-number">2</span>: Hello</code></pre></div>
<ol start="5">
<li><strong>Summary:</strong>
<ul>
<li>The <code>substring()</code> method in Java is used to extract a portion of a string based on the specified indices.</li>
<li>It provides flexibility to extract substrings starting from a specific index or within a range of indices.</li>
<li>The output of the <code>substring()</code> method is a new string containing the extracted substring.</li>
</ul>
</li>
</ol>
<p>In summary, the <code>String.substring()</code> method in Java is a useful tool for extracting specific parts of a string, allowing for efficient manipulation and processing of string data.</p>
<hr />
<h2 id="stringtochararray-method"><code>String.toCharArray()</code> Method</h2>
<p>The <code>String.toCharArray()</code> method in Java is used to convert a <code>String</code> object into a character array (<code>char[]</code>). Here is an explanation of the <code>String.toCharArray()</code> method:</p>
<ol>
<li>
<p><strong>Method Signature:</strong></p>
<ul>
<li>The <code>toCharArray()</code> method is defined in the <code>String</code> class in Java.</li>
<li>It has the following signature:<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-type">char</span>[] toCharArray()</code></pre></div>
</li>
</ul>
</li>
<li>
<p><strong>Return Type:</strong></p>
<ul>
<li>The <code>toCharArray()</code> method returns a newly allocated character array containing the characters of the <code>String</code> object.</li>
</ul>
</li>
<li>
<p><strong>Usage:</strong></p>
<ul>
<li>When you call <code>toCharArray()</code> on a <code>String</code> object, it creates and returns a new character array that contains the characters of the original string.</li>
</ul>
</li>
<li>
<p><strong>Example:</strong></p>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ToCharArrayExample</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">"Hello, World!"</span>;
        
        <span class="hljs-comment">// Convert the string to a character array</span>
        <span class="hljs-type">char</span>[] charArray = str.toCharArray();
        
        <span class="hljs-comment">// Print the elements of the character array</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : charArray) {
            System.out.print(c + <span class="hljs-string">" "</span>);
        }
    }
}</code></pre></div>
</li>
<li>
<p><strong>Explanation of Example:</strong></p>
<ul>
<li>In the code example, a <code>String</code> object <code>str</code> is created with the value “Hello, World!”.</li>
<li>The <code>toCharArray()</code> method is called on the <code>str</code> object to convert it into a character array.</li>
<li>The characters in the resulting character array are then printed using an enhanced for loop.</li>
</ul>
</li>
<li>
<p><strong>Output:</strong></p>
<div><pre class="hljs"><code><span class="hljs-built_in">H</span> e l l o ,   W o <span class="hljs-built_in">r</span> l d !</code></pre></div>
</li>
<li>
<p><strong>Use Cases:</strong></p>
<ul>
<li>The <code>toCharArray()</code> method is useful when you need to work with individual characters in a string as an array.</li>
<li>It allows for easy iteration, manipulation, or processing of characters in the string.</li>
</ul>
</li>
<li>
<p><strong>Key Points:</strong></p>
<ul>
<li>The <code>toCharArray()</code> method provides a convenient way to convert a <code>String</code> into a character array for character-level operations.</li>
<li>The resulting character array is a new copy of the characters in the original string.</li>
</ul>
</li>
</ol>
<p>In summary, the <code>toCharArray()</code> method in Java is a useful method for converting a <code>String</code> object into a character array, enabling easy access and manipulation of individual characters in the string.</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Priority Queue in Java]]></title>
            <guid>c230a96e7906440d89b472ace3ee4da5</guid>
            <pubDate>Mon, 01 Jul 2024 03:43:30 GMT</pubDate>
            <content:encoded><![CDATA[<p>Java Priority Queue code example :</p>
<div><pre class="hljs"><code><span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.List;
<span class="hljs-keyword">import</span> java.util.Scanner;
<span class="hljs-keyword">import</span> java.util.Comparator;
<span class="hljs-keyword">import</span> java.util.PriorityQueue;

<span class="hljs-comment">// Student class representing a student with name, CGPA, and ID</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Student&gt; {
    String name;
    <span class="hljs-type">double</span> cgpa;
    <span class="hljs-type">int</span> id;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">double</span> cgpa, <span class="hljs-type">int</span> id)</span> {
        <span class="hljs-built_in">this</span>.name = name;
        <span class="hljs-built_in">this</span>.cgpa = cgpa;
        <span class="hljs-built_in">this</span>.id = id;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;
    }

    <span class="hljs-comment">// Compare students based on CGPA, name, and ID</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Student s)</span> {
        <span class="hljs-keyword">if</span> (cgpa == s.cgpa) {
            <span class="hljs-keyword">if</span> (name.compareTo(s.name) == <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">if</span> (id == s.id)
                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (id &gt; s.id)
                    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
                <span class="hljs-keyword">else</span>
                    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
            } <span class="hljs-keyword">else</span>
                <span class="hljs-keyword">return</span> name.compareTo(s.name);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cgpa &gt; s.cgpa)
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
        <span class="hljs-keyword">else</span>
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }
}

<span class="hljs-comment">// Priorities class to handle student priorities</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Priorities</span> {
    <span class="hljs-keyword">public</span> ArrayList&lt;Student&gt; <span class="hljs-title function_">getStudents</span><span class="hljs-params">(List&lt;String&gt; events)</span> {
        PriorityQueue&lt;Student&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();
        <span class="hljs-keyword">for</span> (String i : events) {
            String[] s = i.split(<span class="hljs-string">"\\s"</span>);
            <span class="hljs-keyword">if</span> (s.length &gt; <span class="hljs-number">1</span>) {
                pq.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(s[<span class="hljs-number">1</span>], Double.valueOf(s[<span class="hljs-number">2</span>]), Integer.valueOf(s[<span class="hljs-number">3</span>])));
            } <span class="hljs-keyword">else</span> {
                pq.poll();
            }
        }
        <span class="hljs-keyword">while</span> (pq.size() &gt; <span class="hljs-number">1</span>) {
            System.out.println(pq.poll().name);
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Student&gt;(pq);
    }
}

<span class="hljs-comment">// Main solution class</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Scanner</span> <span class="hljs-variable">scan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Priorities</span> <span class="hljs-variable">priorities</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Priorities</span>();

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// Read the total number of events from input</span>
            <span class="hljs-type">int</span> <span class="hljs-variable">totalEvents</span> <span class="hljs-operator">=</span> Integer.parseInt(scan.nextLine());
            List&lt;String&gt; events = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();

            <span class="hljs-comment">// Read and store events from input</span>
            readEvents(totalEvents, events);

            <span class="hljs-comment">// Get students based on events and print their names</span>
            List&lt;Student&gt; students = priorities.getStudents(events);
            printStudents(students);
        } <span class="hljs-keyword">catch</span> (Exception e) {
            System.out.println(<span class="hljs-string">"An error occurred: "</span> + e.getMessage());
        }
    }

    <span class="hljs-comment">// Method to read events from input</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readEvents</span><span class="hljs-params">(<span class="hljs-type">int</span> totalEvents, List&lt;String&gt; events)</span> {
        <span class="hljs-keyword">while</span> (totalEvents-- != <span class="hljs-number">0</span>) {
            <span class="hljs-type">String</span> <span class="hljs-variable">event</span> <span class="hljs-operator">=</span> scan.nextLine();
            events.add(event);
        }
    }

    <span class="hljs-comment">// Method to print students' names</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printStudents</span><span class="hljs-params">(List&lt;Student&gt; students)</span> {
        <span class="hljs-keyword">if</span> (students.isEmpty()) {
            System.out.println(<span class="hljs-string">"EMPTY"</span>);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">for</span> (Student st : students) {
                System.out.println(st.getName());
            }
        }
    }
}</code></pre></div>
<p><strong>Sample Input</strong></p>
<pre style="background:linear-gradient(to right, #F3F7EC, white);color:#3F4E4F;padding:5px" class="jop-noMdConv">
12
ENTER John 3.75 50
ENTER Mark 3.8 24
ENTER Shafaet 3.7 35
SERVED
SERVED
ENTER Samiha 3.85 36
SERVED
ENTER Ashley 3.9 42
ENTER Maria 3.6 46
ENTER Anik 3.95 49
ENTER Dan 3.95 50
SERVED
</pre>
<p><strong>Sample Output</strong></p>
<pre style="background:linear-gradient(to right, #FFE6E6, white);color:#3F4E4F;padding:5px" class="jop-noMdConv">
Dan
Ashley
Shafaet
Maria
</pre>
<h2 id="elucidation">Elucidation</h2>
<p>The provided code is a Java program that demonstrates the use of classes and methods to manage a list of students based on their priorities. Here is a detailed explanation of the code:</p>
<ol>
<li>
<p><strong>Student Class (<code>class Student implements Comparable&lt;Student&gt;</code>)</strong></p>
<ul>
<li>The <code>Student</code> class represents a student with attributes such as name, CGPA, and ID.</li>
<li>The <code>compareTo</code> method is implemented to compare students based on their CGPA, name, and ID.</li>
</ul>
</li>
<li>
<p><strong>Priorities Class (<code>class Priorities</code>)</strong></p>
<ul>
<li>The <code>Priorities</code> class contains the <code>getStudents</code> method, which processes a list of events to prioritize students.</li>
<li>It uses a <code>PriorityQueue</code> to store students based on their priorities.</li>
<li>The method adds students to the priority queue or removes the top student based on the events provided.</li>
<li>It prints the names of the top students in the priority queue.</li>
</ul>
</li>
<li>
<p><strong>Main Solution Class (<code>public class Solution</code>)</strong></p>
<ul>
<li>The <code>Solution</code> class contains the main method that orchestrates the program execution.</li>
<li>It reads the total number of events from the input and stores the events in a list.</li>
<li>It calls the <code>getStudents</code> method from the <code>Priorities</code> class to process the events and obtain the prioritized list of students.</li>
<li>It then prints the names of the prioritized students or “EMPTY” if no students are present.</li>
</ul>
</li>
<li>
<p><strong>Additional Methods</strong></p>
<ul>
<li><code>readEvents</code>: A method to read events from the input and store them in a list.</li>
<li><code>printStudents</code>: A method to print the names of the prioritized students.</li>
</ul>
</li>
<li>
<p><strong>Execution Flow</strong></p>
<ul>
<li>The program starts by reading the total number of events and storing them in a list.</li>
<li>The <code>getStudents</code> method prioritizes students based on the events provided.</li>
<li>The program then prints the names of the prioritized students or “EMPTY” if no students are present.</li>
</ul>
</li>
<li>
<p><strong>Improvements</strong></p>
<ul>
<li>Try-catch blocks are used to handle exceptions and provide error messages if any issues occur during execution.</li>
<li>The code is structured with smaller methods and comments added to explain each section for better readability and maintainability.</li>
</ul>
</li>
</ol>
<p>Overall, the code showcases a structured approach to managing student priorities using classes, methods, and data structures in Java. It demonstrates how to handle and process events to prioritize students effectively.</p>
<hr />
<h2 id="the-priorityqueue-class">The <code>PriorityQueue</code> class</h2>
<p>The <code>PriorityQueue</code> class in Java is an implementation of a priority queue data structure, where elements are processed based on their priority. Lower values are considered higher priority and are processed before higher values. Here is a detailed explanation along with a code example and its output:</p>
<ol>
<li><strong>Code Example:</strong></li>
</ol>
<div><pre class="hljs"><code><span class="hljs-keyword">import</span> java.util.PriorityQueue;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityQueueExample</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// Create a PriorityQueue of integers</span>
        PriorityQueue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();

        <span class="hljs-comment">// Add elements to the PriorityQueue</span>
        pq.add(<span class="hljs-number">30</span>);
        pq.add(<span class="hljs-number">10</span>);
        pq.add(<span class="hljs-number">20</span>);
        pq.add(<span class="hljs-number">5</span>);

        <span class="hljs-comment">// Remove and print elements from the PriorityQueue</span>
        <span class="hljs-keyword">while</span> (!pq.isEmpty()) {
            System.out.println(pq.poll());
        }
    }
}</code></pre></div>
<ol start="2">
<li>
<p><strong>Output Explanation:</strong></p>
<ul>
<li>The code creates a <code>PriorityQueue</code> of integers.</li>
<li>Elements <code>30</code>, <code>10</code>, <code>20</code>, and <code>5</code> are added to the PriorityQueue.</li>
<li>As <code>poll()</code> method is called on the PriorityQueue, elements are removed based on their priority (ascending order).</li>
<li>The elements are printed in ascending order as they are removed from the PriorityQueue.</li>
</ul>
</li>
<li>
<p><strong>Output:</strong></p>
</li>
</ol>
<div><pre class="hljs"><code>5
10
20
30</code></pre></div>
<ol start="4">
<li>
<p><strong>Explanation:</strong></p>
<ul>
<li>Initially, the PriorityQueue contains elements <code>30</code>, <code>10</code>, <code>20</code>, and <code>5</code>.</li>
<li>As elements are removed using the <code>poll()</code> method, the element with the lowest value (highest priority) is removed first.</li>
<li>The output displays the elements in ascending order (<code>5</code>, <code>10</code>, <code>20</code>, <code>30</code>) as they are removed from the PriorityQueue.</li>
</ul>
</li>
<li>
<p><strong>Key Points:</strong></p>
<ul>
<li>Elements in a PriorityQueue are ordered based on their natural ordering or a custom Comparator.</li>
<li>The <code>add()</code> method is used to insert elements into the PriorityQueue, and the <code>poll()</code> method removes and returns the head of the PriorityQueue.</li>
<li>PriorityQueue maintains the elements in a sorted order based on their priority.</li>
</ul>
</li>
</ol>
<p>In summary, the <code>PriorityQueue</code> class in Java provides an efficient way to manage elements based on their priority. It is commonly used in scenarios where elements need to be processed in a specific order. The example demonstrates how to use a PriorityQueue to maintain elements in sorted order based on their priority.</p>
]]></content:encoded>
        </item>
    </channel>
</rss>