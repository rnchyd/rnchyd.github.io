<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title></title>
        <link>undefined</link>
        <description>undefined</description>
        <lastBuildDate>Mon, 22 Jul 2024 17:07:17 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>Joplin Pages Publisher</generator>
        <item>
            <title><![CDATA[Optimal Techniques for Searching and Inserting Arrays and Collections in Java]]></title>
            <guid>d3784106d49e4be89d0d7ed5c2a0f64c</guid>
            <pubDate>Mon, 22 Jul 2024 16:36:08 GMT</pubDate>
            <content:encoded><![CDATA[<h2 id="arrays">Arrays</h2>
<p>The most effective way to search for a specific long value in a 50,000-element array in Java depends on whether the array is sorted or unsorted:</p>
<ul>
<li><strong>If the array is sorted</strong>, using a binary search is the most efficient method with a time complexity of O(log n).</li>
<li><strong>If the array is unsorted</strong>, a linear search is the way to go with a time complexity of O(n).</li>
</ul>
<h3 id="binary-search-for-sorted-array">Binary Search (for sorted array)</h3>
<p>Here’s an example using <code>Arrays.binarySearch()</code> for a sorted array:</p>
<div><pre class="hljs"><code><span class="hljs-keyword">import</span> java.util.Arrays;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// Create and populate a sorted array with 50,000 long values</span>
        <span class="hljs-type">long</span>[] sortedArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[<span class="hljs-number">50000</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; sortedArray.length; i++) {
            sortedArray[i] = i + <span class="hljs-number">1</span>; <span class="hljs-comment">// Example: filling array with values 1 to 50000</span>
        }

        <span class="hljs-comment">// Value to search for</span>
        <span class="hljs-type">long</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-number">25000</span>;

        <span class="hljs-comment">// Perform binary search</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> Arrays.binarySearch(sortedArray, target);

        <span class="hljs-comment">// Print the result</span>
        <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) {
            System.out.println(<span class="hljs-string">"Value "</span> + target + <span class="hljs-string">" found at index "</span> + index);
        } <span class="hljs-keyword">else</span> {
            System.out.println(<span class="hljs-string">"Value "</span> + target + <span class="hljs-string">" not found"</span>);
        }
    }
}</code></pre></div>
<p>Output:</p>
<div><pre class="hljs"><code><span class="hljs-attribute">Value</span> <span class="hljs-number">25000</span> found at index <span class="hljs-number">24999</span></code></pre></div>
<h3 id="linear-search-for-unsorted-array">Linear Search (for unsorted array)</h3>
<p>Here’s an example using a linear search for an unsorted array:</p>
<div><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// Create and populate an unsorted array with 50,000 long values</span>
        <span class="hljs-type">long</span>[] unsortedArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[<span class="hljs-number">50000</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; unsortedArray.length; i++) {
            unsortedArray[i] = (<span class="hljs-type">long</span>) (Math.random() * <span class="hljs-number">50000</span>); <span class="hljs-comment">// Example: random values</span>
        }

        <span class="hljs-comment">// Value to search for</span>
        <span class="hljs-type">long</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-number">25000</span>;

        <span class="hljs-comment">// Perform linear search</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; unsortedArray.length; i++) {
            <span class="hljs-keyword">if</span> (unsortedArray[i] == target) {
                index = i;
                <span class="hljs-keyword">break</span>;
            }
        }

        <span class="hljs-comment">// Print the result</span>
        <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) {
            System.out.println(<span class="hljs-string">"Value "</span> + target + <span class="hljs-string">" found at index "</span> + index);
        } <span class="hljs-keyword">else</span> {
            System.out.println(<span class="hljs-string">"Value "</span> + target + <span class="hljs-string">" not found"</span>);
        }
    }
}</code></pre></div>
<p>Output:</p>
<div><pre class="hljs"><code><span class="hljs-keyword">Value</span> <span class="hljs-number">25000</span> <span class="hljs-built_in">found</span> at <span class="hljs-keyword">index</span> X (<span class="hljs-keyword">if</span> <span class="hljs-built_in">found</span>)
<span class="hljs-keyword">Value</span> <span class="hljs-number">25000</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">found</span> (<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">found</span>)</code></pre></div>
<h3 id="key-points">Key Points</h3>
<ul>
<li><strong>Binary Search</strong>: Use <code>Arrays.binarySearch()</code> on a sorted array for efficient searching with O(log n) time complexity.</li>
<li><strong>Linear Search</strong>: Use a simple <code>for</code> loop to search through an unsorted array with O(n) time complexity.</li>
</ul>
<p>Choose the method based on whether your array is sorted or unsorted for optimal performance.</p>
<h2 id="arraylist">ArrayList</h2>
<p>To search for a specific long value in a <code>ArrayList&lt;Long&gt;</code> with 50,000 elements in Java, you can use the <code>contains()</code> method for simplicity, or a <code>for</code> loop for more control. Here’s how you can do it:</p>
<h3 id="using-contains">Using <code>contains()</code></h3>
<p>The <code>contains()</code> method internally uses a linear search, which has a time complexity of O(n).</p>
<div><pre class="hljs"><code><span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// Create and populate an ArrayList with 50,000 long values</span>
        List&lt;Long&gt; arrayList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-number">50000</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">50000</span>; i++) {
            arrayList.add(i); <span class="hljs-comment">// Example: filling list with values 1 to 50000</span>
        }

        <span class="hljs-comment">// Value to search for</span>
        <span class="hljs-type">long</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-number">25000</span>;

        <span class="hljs-comment">// Perform search using contains()</span>
        <span class="hljs-type">boolean</span> <span class="hljs-variable">found</span> <span class="hljs-operator">=</span> arrayList.contains(target);

        <span class="hljs-comment">// Print the result</span>
        <span class="hljs-keyword">if</span> (found) {
            System.out.println(<span class="hljs-string">"Value "</span> + target + <span class="hljs-string">" found in the list."</span>);
        } <span class="hljs-keyword">else</span> {
            System.out.println(<span class="hljs-string">"Value "</span> + target + <span class="hljs-string">" not found in the list."</span>);
        }
    }
}</code></pre></div>
<p>Output:</p>
<div><pre class="hljs"><code><span class="hljs-attribute">Value</span> <span class="hljs-number">25000</span> found in the list.</code></pre></div>
<h3 id="using-a-for-loop">Using a <code>for</code> Loop</h3>
<p>If you want more control over the search process (e.g., to find the index of the target value), you can use a <code>for</code> loop:</p>
<div><pre class="hljs"><code><span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// Create and populate an ArrayList with 50,000 long values</span>
        List&lt;Long&gt; arrayList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-number">50000</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">50000</span>; i++) {
            arrayList.add(i); <span class="hljs-comment">// Example: filling list with values 1 to 50000</span>
        }

        <span class="hljs-comment">// Value to search for</span>
        <span class="hljs-type">long</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-number">25000</span>;

        <span class="hljs-comment">// Perform linear search using a for loop</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arrayList.size(); i++) {
            <span class="hljs-keyword">if</span> (arrayList.get(i).equals(target)) {
                index = i;
                <span class="hljs-keyword">break</span>;
            }
        }

        <span class="hljs-comment">// Print the result</span>
        <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) {
            System.out.println(<span class="hljs-string">"Value "</span> + target + <span class="hljs-string">" found at index "</span> + index);
        } <span class="hljs-keyword">else</span> {
            System.out.println(<span class="hljs-string">"Value "</span> + target + <span class="hljs-string">" not found in the list."</span>);
        }
    }
}</code></pre></div>
<p>Output:</p>
<div><pre class="hljs"><code><span class="hljs-attribute">Value</span> <span class="hljs-number">25000</span> found at index <span class="hljs-number">24999</span></code></pre></div>
<h3 id="key-points-2">Key Points</h3>
<ul>
<li><strong>Using <code>contains()</code></strong>: Simple and straightforward, but you won’t get the index of the found element.</li>
<li><strong>Using a <code>for</code> Loop</strong>: Provides more control and allows you to find the index of the element.</li>
</ul>
<p>Both methods perform a linear search, which is the most efficient approach for unsorted lists. If the list is sorted and you need faster search performance, consider using a <code>binary search</code> on a <code>List</code> by converting it to an array or using a <code>TreeSet</code> instead of an <code>ArrayList</code>.</p>
<h2 id="linkedlist">LinkedList</h2>
<p>To search for a specific long value in a <code>LinkedList&lt;Long&gt;</code> with 50,000 elements in Java, you typically use a linear search. This is because <code>LinkedList</code> does not support efficient random access, and a binary search would not be effective.</p>
<h3 id="using-a-for-loop-2">Using a <code>for</code> Loop</h3>
<p>Here’s an example using a <code>for</code> loop to perform a linear search:</p>
<div><pre class="hljs"><code><span class="hljs-keyword">import</span> java.util.LinkedList;
<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// Create and populate a LinkedList with 50,000 long values</span>
        List&lt;Long&gt; linkedList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">50000</span>; i++) {
            linkedList.add(i); <span class="hljs-comment">// Example: filling list with values 1 to 50000</span>
        }

        <span class="hljs-comment">// Value to search for</span>
        <span class="hljs-type">long</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-number">25000</span>;

        <span class="hljs-comment">// Perform linear search using a for loop</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; linkedList.size(); i++) {
            <span class="hljs-keyword">if</span> (linkedList.get(i).equals(target)) {
                index = i;
                <span class="hljs-keyword">break</span>;
            }
        }

        <span class="hljs-comment">// Print the result</span>
        <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) {
            System.out.println(<span class="hljs-string">"Value "</span> + target + <span class="hljs-string">" found at index "</span> + index);
        } <span class="hljs-keyword">else</span> {
            System.out.println(<span class="hljs-string">"Value "</span> + target + <span class="hljs-string">" not found in the list."</span>);
        }
    }
}</code></pre></div>
<p>Output:</p>
<div><pre class="hljs"><code><span class="hljs-attribute">Value</span> <span class="hljs-number">25000</span> found at index <span class="hljs-number">24999</span></code></pre></div>
<h3 id="using-an-iterator">Using an Iterator</h3>
<p>Alternatively, you can use an <code>Iterator</code> to traverse the <code>LinkedList</code>, which can be more efficient in terms of memory usage:</p>
<div><pre class="hljs"><code><span class="hljs-keyword">import</span> java.util.LinkedList;
<span class="hljs-keyword">import</span> java.util.List;
<span class="hljs-keyword">import</span> java.util.Iterator;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// Create and populate a LinkedList with 50,000 long values</span>
        List&lt;Long&gt; linkedList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">50000</span>; i++) {
            linkedList.add(i); <span class="hljs-comment">// Example: filling list with values 1 to 50000</span>
        }

        <span class="hljs-comment">// Value to search for</span>
        <span class="hljs-type">long</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-number">25000</span>;

        <span class="hljs-comment">// Perform linear search using an iterator</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;
        <span class="hljs-type">int</span> <span class="hljs-variable">currentIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
        Iterator&lt;Long&gt; iterator = linkedList.iterator();
        <span class="hljs-keyword">while</span> (iterator.hasNext()) {
            <span class="hljs-keyword">if</span> (iterator.next().equals(target)) {
                index = currentIndex;
                <span class="hljs-keyword">break</span>;
            }
            currentIndex++;
        }

        <span class="hljs-comment">// Print the result</span>
        <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) {
            System.out.println(<span class="hljs-string">"Value "</span> + target + <span class="hljs-string">" found at index "</span> + index);
        } <span class="hljs-keyword">else</span> {
            System.out.println(<span class="hljs-string">"Value "</span> + target + <span class="hljs-string">" not found in the list."</span>);
        }
    }
}</code></pre></div>
<p>Output:</p>
<div><pre class="hljs"><code><span class="hljs-attribute">Value</span> <span class="hljs-number">25000</span> found at index <span class="hljs-number">24999</span></code></pre></div>
<h3 id="key-points-3">Key Points</h3>
<ul>
<li><strong>Linear Search</strong>: The most effective way to search a <code>LinkedList</code> due to its sequential nature.</li>
<li><strong>Using an Iterator</strong>: Can be more memory-efficient and avoids the overhead of repeatedly calling <code>get()</code>.</li>
</ul>
<p>Both methods perform a linear search, which is the most appropriate approach for a <code>LinkedList</code> due to its sequential access nature.</p>
<h2 id="hashset">HashSet</h2>
<p>The most effective way to search for a specific long value in a <code>HashSet&lt;Long&gt;</code> in Java is to use the <code>contains()</code> method. The <code>HashSet</code> class is designed for fast lookups, and the <code>contains()</code> method operates with an average time complexity of O(1).</p>
<p>Here’s an example demonstrating this:</p>
<div><pre class="hljs"><code><span class="hljs-keyword">import</span> java.util.HashSet;
<span class="hljs-keyword">import</span> java.util.Set;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// Create and populate a HashSet with 50,000 long values</span>
        Set&lt;Long&gt; hashSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(<span class="hljs-number">50000</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">50000</span>; i++) {
            hashSet.add(i); <span class="hljs-comment">// Example: filling set with values 1 to 50000</span>
        }

        <span class="hljs-comment">// Value to search for</span>
        <span class="hljs-type">long</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-number">25000L</span>;

        <span class="hljs-comment">// Perform search using contains()</span>
        <span class="hljs-type">boolean</span> <span class="hljs-variable">found</span> <span class="hljs-operator">=</span> hashSet.contains(target);

        <span class="hljs-comment">// Print the result</span>
        <span class="hljs-keyword">if</span> (found) {
            System.out.println(<span class="hljs-string">"Value "</span> + target + <span class="hljs-string">" found in the set."</span>);
        } <span class="hljs-keyword">else</span> {
            System.out.println(<span class="hljs-string">"Value "</span> + target + <span class="hljs-string">" not found in the set."</span>);
        }
    }
}</code></pre></div>
<p>Output:</p>
<div><pre class="hljs"><code>Value <span class="hljs-number">25000</span> found <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> <span class="hljs-built_in">set</span>.</code></pre></div>
<h3 id="key-points-4">Key Points</h3>
<ul>
<li><strong>Using <code>HashSet</code></strong>: <code>HashSet</code> is optimized for fast lookups, insertions, and deletions.</li>
<li><strong>Time Complexity</strong>: The <code>contains()</code> method has an average time complexity of O(1), making it very efficient for search operations.</li>
</ul>
<p>This approach leverages the strengths of <code>HashSet</code> to provide quick and efficient search capabilities.</p>
<h2 id="hashmap">HashMap</h2>
<p>The most effective way to search for a specific long value in a <code>HashMap&lt;Long, Long&gt;</code> in Java is to use the <code>containsKey()</code> or <code>containsValue()</code> methods, depending on whether you are searching by key or by value. The <code>HashMap</code> class is optimized for fast lookups, with an average time complexity of O(1) for these operations.</p>
<h3 id="searching-by-key">Searching by Key</h3>
<p>Here’s an example demonstrating how to search for a key in a <code>HashMap</code>:</p>
<div><pre class="hljs"><code><span class="hljs-keyword">import</span> java.util.HashMap;
<span class="hljs-keyword">import</span> java.util.Map;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// Create and populate a HashMap with 50,000 key-value pairs</span>
        Map&lt;Long, Long&gt; hashMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">50000</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">50000</span>; i++) {
            hashMap.put(i, i); <span class="hljs-comment">// Example: filling map with key-value pairs 1 to 50000</span>
        }

        <span class="hljs-comment">// Key to search for</span>
        <span class="hljs-type">long</span> <span class="hljs-variable">targetKey</span> <span class="hljs-operator">=</span> <span class="hljs-number">25000L</span>;

        <span class="hljs-comment">// Perform search using containsKey()</span>
        <span class="hljs-type">boolean</span> <span class="hljs-variable">keyFound</span> <span class="hljs-operator">=</span> hashMap.containsKey(targetKey);

        <span class="hljs-comment">// Print the result</span>
        <span class="hljs-keyword">if</span> (keyFound) {
            System.out.println(<span class="hljs-string">"Key "</span> + targetKey + <span class="hljs-string">" found in the map."</span>);
        } <span class="hljs-keyword">else</span> {
            System.out.println(<span class="hljs-string">"Key "</span> + targetKey + <span class="hljs-string">" not found in the map."</span>);
        }
    }
}</code></pre></div>
<p>Output:</p>
<div><pre class="hljs"><code><span class="hljs-attribute">Key</span> <span class="hljs-number">25000</span> found in the map.</code></pre></div>
<h3 id="searching-by-value">Searching by Value</h3>
<p>Here’s an example demonstrating how to search for a value in a <code>HashMap</code>:</p>
<div><pre class="hljs"><code><span class="hljs-keyword">import</span> java.util.HashMap;
<span class="hljs-keyword">import</span> java.util.Map;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// Create and populate a HashMap with 50,000 key-value pairs</span>
        Map&lt;Long, Long&gt; hashMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">50000</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">50000</span>; i++) {
            hashMap.put(i, i); <span class="hljs-comment">// Example: filling map with key-value pairs 1 to 50000</span>
        }

        <span class="hljs-comment">// Value to search for</span>
        <span class="hljs-type">long</span> <span class="hljs-variable">targetValue</span> <span class="hljs-operator">=</span> <span class="hljs-number">25000L</span>;

        <span class="hljs-comment">// Perform search using containsValue()</span>
        <span class="hljs-type">boolean</span> <span class="hljs-variable">valueFound</span> <span class="hljs-operator">=</span> hashMap.containsValue(targetValue);

        <span class="hljs-comment">// Print the result</span>
        <span class="hljs-keyword">if</span> (valueFound) {
            System.out.println(<span class="hljs-string">"Value "</span> + targetValue + <span class="hljs-string">" found in the map."</span>);
        } <span class="hljs-keyword">else</span> {
            System.out.println(<span class="hljs-string">"Value "</span> + targetValue + <span class="hljs-string">" not found in the map."</span>);
        }
    }
}</code></pre></div>
<p>Output:</p>
<div><pre class="hljs"><code><span class="hljs-attribute">Value</span> <span class="hljs-number">25000</span> found</code></pre></div>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Code Analysis of HR Java Bitset problem solution]]></title>
            <guid>5229b5e53851401a863b2ee4c14953f8</guid>
            <pubDate>Thu, 18 Jul 2024 08:40:44 GMT</pubDate>
            <content:encoded><![CDATA[<p>Given the solution code :</p>
<div><pre class="hljs"><code><span class="hljs-keyword">import</span> java.io.*;
<span class="hljs-keyword">import</span> java.util.*;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);
            <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> sc.nextInt();
            <span class="hljs-type">BitSet</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BitSet</span>(length);
            <span class="hljs-type">BitSet</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BitSet</span>(length);
        
            BitSet[] b = {b1, b2};
        
            <span class="hljs-type">int</span> <span class="hljs-variable">operations</span> <span class="hljs-operator">=</span> sc.nextInt();
        
            performOperations(sc, b, operations);
        
            sc.close();
        } <span class="hljs-keyword">catch</span> (Exception e) {
            System.out.println(<span class="hljs-string">"An error occurred: "</span> + e.getMessage());
        }
    }
    
    <span class="hljs-comment">// Method to perform the specified operations on BitSets</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">performOperations</span><span class="hljs-params">(Scanner sc, BitSet[] b, <span class="hljs-type">int</span> operations)</span> {
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; operations; i++) {
            <span class="hljs-keyword">try</span> {
                sc.nextLine();
                <span class="hljs-type">String</span> <span class="hljs-variable">operation</span> <span class="hljs-operator">=</span> sc.next();
                <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> sc.nextInt() - <span class="hljs-number">1</span>;
                <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> sc.nextInt() - <span class="hljs-number">1</span>; 
                
                applyOperation(b, operation, x, y);
                
                System.out.println(b[<span class="hljs-number">0</span>].cardinality() + <span class="hljs-string">" "</span> + b[<span class="hljs-number">1</span>].cardinality());
            } <span class="hljs-keyword">catch</span> (Exception e) {
                System.out.println(<span class="hljs-string">"An error occurred during operation: "</span> + e.getMessage());
            }
        }
    }
    
    <span class="hljs-comment">// Method to apply the specified operation on the BitSets</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">applyOperation</span><span class="hljs-params">(BitSet[] b, String operation, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> {
        <span class="hljs-keyword">switch</span> (operation) {
            <span class="hljs-keyword">case</span> <span class="hljs-string">"AND"</span>:
                b[x].and(b[y]);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-string">"OR"</span>:
                b[x].or(b[y]);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-string">"XOR"</span>:
                b[x].xor(b[y]);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-string">"FLIP"</span>:
                b[x].flip(y + <span class="hljs-number">1</span>);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-string">"SET"</span>:
                b[x].set(y + <span class="hljs-number">1</span>);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">default</span>:
                System.out.println(<span class="hljs-string">"Invalid operation: "</span> + operation);
        }
    }
}</code></pre></div>
<p><strong>Sample Input</strong></p>
<pre style="background:linear-gradient(to right, #F3F7EC, white);color:#3F4E4F;padding:5px" class="jop-noMdConv">
5 4
AND 1 2
SET 1 4
FLIP 2 2
OR 2 1
</pre>
<p><strong>Sample Output</strong></p>
<pre style="background:linear-gradient(to right, #FFE6E6, white);color:#3F4E4F;padding:5px" class="jop-noMdConv">
0 0
1 0
1 1
1 2
</pre>
<h2 id="elucidation">Elucidation</h2>
<ol>
<li>
<p><strong>Main Method</strong> (<code>public static void main(String[] args)</code>):</p>
<ul>
<li>The <code>main</code> method is the entry point of the program.</li>
<li>It includes a try-catch block to handle any exceptions that may occur during program execution.</li>
<li>Within the try block, it initializes a <code>Scanner</code> object to read input from the user.</li>
<li>It reads the length of the BitSets and the number of operations to be performed.</li>
<li>It then calls the <code>performOperations</code> method to handle the logic of performing operations on the BitSets.</li>
<li>Finally, it closes the <code>Scanner</code> object after all operations are completed.</li>
</ul>
</li>
<li>
<p><strong>performOperations Method</strong> (<code>private static void performOperations(Scanner sc, BitSet[] b, int operations)</code>):</p>
<ul>
<li>This method takes a <code>Scanner</code> object, an array of BitSets, and the number of operations as parameters.</li>
<li>It iterates through the specified number of operations and applies each operation on the BitSets.</li>
<li>For each operation, it calls the <code>applyOperation</code> method to perform the specific operation on the BitSets.</li>
<li>It also catches any exceptions that may occur during the operation and prints an error message.</li>
</ul>
</li>
<li>
<p><strong>applyOperation Method</strong> (<code>private static void applyOperation(BitSet[] b, String operation, int x, int y)</code>):</p>
<ul>
<li>This method takes an array of BitSets, the operation to be performed, and the indices <code>x</code> and <code>y</code> as parameters.</li>
<li>It uses a switch-case statement to determine the type of operation to be applied on the BitSets.</li>
<li>Depending on the operation type, it calls the corresponding method on the BitSets (<code>and</code>, <code>or</code>, <code>xor</code>, <code>flip</code>, or <code>set</code>).</li>
</ul>
</li>
<li>
<p><strong>Error Handling</strong>:</p>
<ul>
<li>Both the <code>main</code> method and the <code>performOperations</code> method have try-catch blocks to handle exceptions gracefully.</li>
<li>If an exception occurs during input reading or operation execution, an error message is displayed to notify the user.</li>
</ul>
</li>
</ol>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Code Analysis of HR Java Sort problem solution]]></title>
            <guid>fcc24ac32d4d4bb0a04dc54be37aede8</guid>
            <pubDate>Thu, 18 Jul 2024 06:53:54 GMT</pubDate>
            <content:encoded><![CDATA[<h2 id="problem">Problem</h2>
<p>You are given a list of student information: ID, FirstName, and CGPA. Your task is to rearrange them according to their CGPA in decreasing order. If two student have the same CGPA, then arrange them according to their first name in alphabetical order. If those two students also have the same first name, then order them according to their ID. No two students have the same ID.</p>
<p><strong>Input Format</strong></p>
<p>The first line of input contains an integer <code>N</code>, representing the total number of students. The next <code>N</code> lines contains a list of student information in the following structure:</p>
<div><pre class="hljs"><code>ID <span class="hljs-keyword">Name</span> CGPA</code></pre></div>
<p><strong>Constraints</strong></p>
<p><code>2 &lt; N &lt; 1000</code></p>
<p><code>0 ≤ ID &lt; 100000</code></p>
<p><code>5 ≤ |Name ≤ 30</code></p>
<p><code>0 &lt;CGPA &lt; 4.00</code></p>
<p>The name contains only lowercase English letters. The <code>ID</code> contains only integer numbers without leading zeros. The CGPA will contain, at most, 2 digits after the decimal point.</p>
<p><strong>Output Format</strong></p>
<p>After rearranging the students according to the above rules, print the first name of each student on a separate line.</p>
<p><strong>Sample Input</strong></p>
<pre style="background:linear-gradient(to right, #F3F7EC, white);color:#3F4E4F;padding:5px" class="jop-noMdConv">
5
33 Rumpa 3.68
85 Ashis 3.85
56 Samiha 3.75
19 Samara 3.75
22 Fahim 3.76
</pre>
<p><strong>Sample Output</strong></p>
<pre style="background:linear-gradient(to right, #FFE6E6, white);color:#3F4E4F;padding:5px" class="jop-noMdConv">
Ashis
Fahim
Samara
Samiha
Rumpa
</pre>
<h2 id="solution">Solution</h2>
<p>The Java code for the problem above</p>
<div><pre class="hljs"><code><span class="hljs-keyword">import</span> java.util.*;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Student&gt; {
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;
    <span class="hljs-keyword">private</span> String fname;
    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> cgpa;
    
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String fname, <span class="hljs-type">double</span> cgpa)</span> {
        <span class="hljs-built_in">super</span>();
        <span class="hljs-built_in">this</span>.id = id;
        <span class="hljs-built_in">this</span>.fname = fname;
        <span class="hljs-built_in">this</span>.cgpa = cgpa;
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> id;
    }
    
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getFname</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> fname;
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getCgpa</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> cgpa;
    }
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Student s)</span> {
        <span class="hljs-comment">// Compare students based on CGPA, first name, and ID</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.cgpa != s.cgpa) {
            <span class="hljs-keyword">return</span> Double.compare(s.cgpa, <span class="hljs-built_in">this</span>.cgpa); <span class="hljs-comment">// Sort by CGPA in descending order</span>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.fname.equals(s.fname)) {
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.fname.compareTo(s.fname); <span class="hljs-comment">// Sort by first name in alphabetical order</span>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> Integer.compare(<span class="hljs-built_in">this</span>.id, s.id); <span class="hljs-comment">// Sort by ID if first names are the same</span>
        }
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);
        <span class="hljs-type">int</span> <span class="hljs-variable">testCases</span> <span class="hljs-operator">=</span> Integer.parseInt(in.nextLine());
        
        List&lt;Student&gt; studentList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        <span class="hljs-keyword">while</span> (testCases &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> in.nextInt();
            <span class="hljs-type">String</span> <span class="hljs-variable">fname</span> <span class="hljs-operator">=</span> in.next();
            <span class="hljs-type">double</span> <span class="hljs-variable">cgpa</span> <span class="hljs-operator">=</span> in.nextDouble();
            
            <span class="hljs-type">Student</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(id, fname, cgpa);
            studentList.add(st);
            
            testCases--;
        }
        
        Collections.sort(studentList); <span class="hljs-comment">// Sort the studentList based on the compareTo method in Student class</span>
        
        <span class="hljs-keyword">for</span> (Student st : studentList) {
            System.out.println(st.getFname()); <span class="hljs-comment">// Print the first name of each student</span>
        }
    }
}</code></pre></div>
<h2 id="elucidation">Elucidation</h2>
<ol>
<li>
<p><strong>Student Class</strong>:</p>
<ul>
<li>The <code>Student</code> class represents a student with attributes <code>id</code>, <code>fname</code> (first name), and <code>cgpa</code> (CGPA).</li>
<li>The class has a constructor to initialize the student object with the provided values.</li>
<li>It also includes getter methods to retrieve the <code>id</code>, <code>fname</code>, and <code>cgpa</code> of a student.</li>
<li>The class implements the <code>Comparable</code> interface to define a natural ordering for instances of the class.</li>
</ul>
</li>
<li>
<p><strong>Solution Class</strong>:</p>
<ul>
<li>The <code>Solution</code> class contains the <code>main</code> method where the program execution starts.</li>
<li>It reads input from the user using a <code>Scanner</code> object.</li>
<li>It initializes an empty <code>ArrayList</code> named <code>studentList</code> to store instances of the <code>Student</code> class.</li>
<li>It reads the number of test cases from the input and loops through each test case to read student information (id, first name, and CGPA) from the input.</li>
<li>For each test case, a new <code>Student</code> object is created with the provided information and added to the <code>studentList</code>.</li>
<li>After reading all test cases, the <code>Collections.sort()</code> method is used to sort the <code>studentList</code> based on the natural ordering defined in the <code>compareTo</code> method of the <code>Student</code> class.</li>
<li>Finally, it iterates over the sorted <code>studentList</code> and prints the first name of each student.</li>
</ul>
</li>
<li>
<p><strong>Sorting Logic</strong>:</p>
<ul>
<li>The <code>compareTo</code> method in the <code>Student</code> class compares two <code>Student</code> objects based on their CGPA, first name, and ID in that order.</li>
<li>If two students have different CGPA, they are sorted in descending order of CGPA.</li>
<li>If two students have the same CGPA, they are sorted in alphabetical order of their first names.</li>
<li>If two students have the same first name, they are sorted based on their IDs.</li>
</ul>
</li>
</ol>
<p>Overall, this code reads student information, creates <code>Student</code> objects, sorts them according to the specified rules, and then prints the first name of each student in the sorted order. The <code>Comparable</code> interface is used to define the custom sorting logic based on CGPA, first name, and ID.</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Unlocking Efficiency: Exploring the Benefits of Python Virtual Environments in Development]]></title>
            <guid>c9166eabae694de1b9e5f063b92b2636</guid>
            <pubDate>Tue, 09 Jul 2024 05:31:38 GMT</pubDate>
            <content:encoded><![CDATA[<p><strong>Summary</strong><br />
Virtual environments in Python development offer several advantages, including isolation of project dependencies, maintaining clean and consistent environments, avoiding conflicts between project requirements, ensuring portability across different systems, and facilitating collaboration with others.</p>
<p><strong>Key Advantages</strong></p>
<ol>
<li><strong>Dependency Isolation</strong>: Virtual environments separate project dependencies, preventing conflicts between different projects.</li>
<li><strong>Environment Consistency</strong>: Maintains a clean environment for each project, ensuring consistent behavior and reproducibility.</li>
<li><strong>Conflict Avoidance</strong>: Avoids conflicts when projects require different versions of the same package.</li>
<li><strong>Portability</strong>: Ensures that projects can be easily moved between different systems while preserving dependencies.</li>
<li><strong>Collaboration</strong>: Facilitates collaboration by sharing project requirements through versioned environment configuration files like <code>requirements.txt</code>.</li>
</ol>
<p>By utilizing virtual environments, Python developers can manage dependencies effectively, minimize compatibility issues, and streamline project development and deployment processes.</p>
<h2 id="create-a-virtual-environment-in-python">Create a virtual environment in Python</h2>
<p><code>python -m venv my-venv</code></p>
<p><strong>Explanation</strong><br />
The command <code>python -m venv my-venv</code> is used to create a virtual environment in Python. Here’s a breakdown of what each part of the command does:</p>
<ul>
<li><code>python</code>: This specifies the Python interpreter to use for creating the virtual environment.</li>
<li><code>-m venv</code>: This part invokes the <code>venv</code> module, which is a built-in module in Python used for creating virtual environments.</li>
<li><code>my-venv</code>: This is the name given to the virtual environment being created. You can replace <code>my-venv</code> with any name you prefer.</li>
</ul>
<p>By running this command in your terminal or command prompt, a new virtual environment named <code>my-venv</code> will be created in the current directory. This virtual environment will have its own isolated Python installation and packages, allowing you to work on projects with specific dependencies without affecting your global Python environment.</p>
<p><code>source my-venv/bin/activate</code></p>
<p>When you run the command <code>source my-venv/bin/activate</code>, it activates a virtual environment named <code>my-venv</code> in your current shell session. Here’s a breakdown of what this command does:</p>
<ul>
<li>
<p><code>source</code>: This command is used to run commands from a file within the current shell session. It reads and executes commands from the specified file and sets any environment variables defined in that file in the current shell.</p>
</li>
<li>
<p><code>my-venv/bin/activate</code>: This specifies the path to the activation script of the virtual environment. When you run this script, it modifies the shell environment to prioritize the Python interpreter and packages located within the virtual environment directory (<code>my-venv</code>) over the global Python installation.</p>
</li>
</ul>
<p>By sourcing the activation script, you’re essentially telling your shell to use the Python interpreter and packages specific to the <code>my-venv</code> virtual environment for any subsequent Python-related commands you execute. This ensures that you work in an isolated environment with project-specific dependencies, enhancing organization and preventing conflicts with other projects or system-wide packages.</p>
<h2 id="deactivate-the-virtual-environment"><code>deactivate</code> the virtual environment</h2>
<p><code>deactivate</code></p>
<p>When you activate a virtual environment in Python, it modifies your shell’s PATH to make sure that when you run Python or pip commands, they refer to the Python interpreter and packages specific to that environment.</p>
<p>Now, when you deactivate a virtual environment, it resets the PATH environment variable to its original state before the virtual environment was activated. This means that any Python or pip commands run after deactivation will use the system’s default Python interpreter and packages, not those specific to the virtual environment.</p>
<p>In essence, deactivating a virtual environment allows you to return to using the global Python installation and system-wide packages, ensuring that your commands are executed in the context of the system environment rather than the isolated virtual environment.</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Code Analysis of HR Minesweeper Game problem solution]]></title>
            <guid>49d8495738504ab5b186660f525eb53a</guid>
            <pubDate>Wed, 03 Jul 2024 19:06:30 GMT</pubDate>
            <content:encoded><![CDATA[<p>Given the solution code :</p>
<div><pre class="hljs"><code><span class="hljs-keyword">import</span> java.util.Scanner;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Minesweeper</span> {
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">char</span>[][] map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];
        
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// Create a Scanner object for user input</span>
            <span class="hljs-type">Scanner</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);
            <span class="hljs-comment">// Read the number of bombs from user input</span>
            <span class="hljs-type">int</span> <span class="hljs-variable">numBombs</span> <span class="hljs-operator">=</span> input.nextInt();
            
            <span class="hljs-comment">// Populate the map with bombs based on user input</span>
            populateBombs(map, input, numBombs);
            <span class="hljs-comment">// Update the map with bomb counts</span>
            updateMapWithCounts(map);
            <span class="hljs-comment">// Print the updated map</span>
            printMap(map);
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-comment">// Handle any exceptions that occur during execution</span>
            System.out.println(<span class="hljs-string">"An error occurred: "</span> + e.getMessage());
        }
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">populateBombs</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] map, Scanner input, <span class="hljs-type">int</span> numBombs)</span> {
        <span class="hljs-comment">// Loop through the number of bombs provided by the user</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numBombs; i++) {
            <span class="hljs-comment">// Read the bomb coordinates from user input and mark them on the map</span>
            String[] bombCoord = input.next().split(<span class="hljs-string">","</span>);
            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> Integer.parseInt(bombCoord[<span class="hljs-number">0</span>]) - <span class="hljs-number">1</span>;
            <span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> Integer.parseInt(bombCoord[<span class="hljs-number">1</span>]) - <span class="hljs-number">1</span>;
            map[row][col] = <span class="hljs-string">'x'</span>;
        }
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateMapWithCounts</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] map)</span> {
        <span class="hljs-comment">// Iterate through each cell in the map</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) {
                <span class="hljs-comment">// Check if the cell is not a bomb</span>
                <span class="hljs-keyword">if</span> (map[i][j] != <span class="hljs-string">'x'</span>) {
                    <span class="hljs-comment">// Calculate the number of bombs around the cell</span>
                    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> countBombs(map, i, j);
                    <span class="hljs-comment">// Update the cell with the bomb count or '.' if no bombs nearby</span>
                    map[i][j] = count == <span class="hljs-number">0</span> ? <span class="hljs-string">'.'</span> : (<span class="hljs-type">char</span>)(<span class="hljs-string">'0'</span> + count);
                }
            }
        }
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printMap</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] map)</span> {
        <span class="hljs-comment">// Print the map to the console</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) {
                System.out.print(map[i][j]);
            }
            System.out.println();
        }
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countBombs</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] map, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span> {
        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
        <span class="hljs-comment">// Iterate through neighboring cells to count bombs</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">0</span>, row - <span class="hljs-number">1</span>); i &lt;= Math.min(<span class="hljs-number">9</span>, row + <span class="hljs-number">1</span>); i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">0</span>, col - <span class="hljs-number">1</span>); j &lt;= Math.min(<span class="hljs-number">9</span>, col + <span class="hljs-number">1</span>); j++) {
                <span class="hljs-comment">// Check if the cell contains a bomb</span>
                <span class="hljs-keyword">if</span> (map[i][j] == <span class="hljs-string">'x'</span>) {
                    count++;
                }
            }
        }
        <span class="hljs-keyword">return</span> count;
    }
}</code></pre></div>
<h2 id="elucidation">Elucidation</h2>
<p><strong>Explanation:</strong><br />
This Java program simulates a simple Minesweeper game where the user can input the number of bombs and their coordinates, and the program will populate the map with bombs and update the map with bomb counts around each cell.</p>
<ol>
<li>
<p><strong>Main Method:</strong></p>
<ul>
<li>The <code>main</code> method initializes a 10x10 char array to represent the game map.</li>
<li>It reads the number of bombs from the user, populates the bombs on the map, updates the map with bomb counts, and then prints the map.</li>
</ul>
</li>
<li>
<p><strong>Populate Bombs Method:</strong></p>
<ul>
<li>The <code>populateBombs</code> method takes the map, user input scanner, and the number of bombs as parameters.</li>
<li>It reads the bomb coordinates from the user input and marks those positions with ‘x’ on the map.</li>
</ul>
</li>
<li>
<p><strong>Update Map with Counts Method:</strong></p>
<ul>
<li>The <code>updateMapWithCounts</code> method iterates over each cell in the map.</li>
<li>For each empty cell (not a bomb), it calculates the number of bombs surrounding that cell and updates the cell with the bomb count or ‘.’ if no bombs are nearby.</li>
</ul>
</li>
<li>
<p><strong>Print Map Method:</strong></p>
<ul>
<li>The <code>printMap</code> method simply prints the current state of the map to the console.</li>
</ul>
</li>
<li>
<p><strong>Count Bombs Method:</strong></p>
<ul>
<li>The <code>countBombs</code> method calculates the number of bombs surrounding a particular cell by checking the neighboring cells within the bounds of the map.</li>
</ul>
</li>
</ol>
<p>This program efficiently handles user input for bomb placement, updates the map with bomb counts, and displays the final map state for the user to play the Minesweeper game.</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Code Analysis of HR Fraudulent Activity Notifications problem solution]]></title>
            <guid>06707c10ef61459ca94ace8a5d9c9e21</guid>
            <pubDate>Wed, 03 Jul 2024 10:36:25 GMT</pubDate>
            <content:encoded><![CDATA[<p>Given the solution code :</p>
<div><pre class="hljs"><code><span class="hljs-keyword">import</span> java.io.*;
<span class="hljs-keyword">import</span> java.math.*;
<span class="hljs-keyword">import</span> java.security.*;
<span class="hljs-keyword">import</span> java.text.*;
<span class="hljs-keyword">import</span> java.util.*;
<span class="hljs-keyword">import</span> java.util.concurrent.*;
<span class="hljs-keyword">import</span> java.util.regex.*;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Result</span> {

    <span class="hljs-comment">/*
     * Complete the 'activityNotifications' function below.
     *
     * The function is expected to return an INTEGER.
     * The function accepts following parameters:
     *  1. INTEGER_ARRAY expenditure
     *  2. INTEGER d
     */</span>

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">activityNotifications</span><span class="hljs-params">(List&lt;Integer&gt; expenditure, <span class="hljs-type">int</span> d)</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// Initialize variables</span>
            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
            <span class="hljs-type">int</span>[] freq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">201</span>];
            
            <span class="hljs-comment">// Initialize frequency array for initial expenditures</span>
            initializeFrequency(expenditure, d, freq);
            
            <span class="hljs-comment">// Calculate notifications based on median comparison</span>
            count = calculateNotifications(expenditure, d, freq);
            
            <span class="hljs-keyword">return</span> count;
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-comment">// Handle any exceptions that occur during the process</span>
            System.out.println(<span class="hljs-string">"An error occurred: "</span> + e.getMessage());
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
        }
    }

    <span class="hljs-comment">// Method to initialize frequency array for initial expenditures</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initializeFrequency</span><span class="hljs-params">(List&lt;Integer&gt; expenditure, <span class="hljs-type">int</span> d, <span class="hljs-type">int</span>[] freq)</span> {
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; d; i++) {
            freq[expenditure.get(i)]++;
        }
    }

    <span class="hljs-comment">// Method to calculate notifications based on median comparison</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateNotifications</span><span class="hljs-params">(List&lt;Integer&gt; expenditure, <span class="hljs-type">int</span> d, <span class="hljs-type">int</span>[] freq)</span> {
        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> d; i &lt; expenditure.size(); i++) {
            <span class="hljs-comment">// Calculate median based on frequency array</span>
            <span class="hljs-type">double</span> <span class="hljs-variable">median</span> <span class="hljs-operator">=</span> calculateMedian(freq, d);
            
            <span class="hljs-comment">// Compare expenditure with double the median for notification</span>
            <span class="hljs-keyword">if</span> (expenditure.get(i) &gt;= <span class="hljs-number">2</span> * median) {
                count++;
            }

            <span class="hljs-comment">// Update frequency array for sliding window</span>
            freq[expenditure.get(i - d)]--;
            freq[expenditure.get(i)]++;
        }
        <span class="hljs-keyword">return</span> count;
    }

    <span class="hljs-comment">// Method to calculate median based on frequency array</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calculateMedian</span><span class="hljs-params">(<span class="hljs-type">int</span>[] freq, <span class="hljs-type">int</span> d)</span> {
        <span class="hljs-type">double</span> <span class="hljs-variable">median</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (d % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) {
            <span class="hljs-comment">// Calculate median for odd window size</span>
            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">201</span>; j++) {
                sum += freq[j];
                <span class="hljs-keyword">if</span> (sum &gt;= d / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) {
                    median = j;
                    <span class="hljs-keyword">break</span>;
                }
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// Calculate median for even window size</span>
            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>, m = -<span class="hljs-number">1</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">201</span>; j++) {
                sum += freq[j];
                <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span> &amp;&amp; sum &gt;= d / <span class="hljs-number">2</span>) {
                    n = j;
                }
                <span class="hljs-keyword">if</span> (sum &gt;= d / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) {
                    m = j;
                    median = (m + n) / <span class="hljs-number">2.0</span>;
                    <span class="hljs-keyword">break</span>;
                }
            }
        }
        <span class="hljs-keyword">return</span> median;
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException {
        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));
        <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bufferedWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(System.getenv(<span class="hljs-string">"OUTPUT_PATH"</span>)));

        String[] firstMultipleInput = bufferedReader.readLine().replaceAll(<span class="hljs-string">"\\s+$"</span>, <span class="hljs-string">""</span>).split(<span class="hljs-string">" "</span>);

        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> Integer.parseInt(firstMultipleInput[<span class="hljs-number">0</span>]);

        <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> Integer.parseInt(firstMultipleInput[<span class="hljs-number">1</span>]);

        String[] expenditureTemp = bufferedReader.readLine().replaceAll(<span class="hljs-string">"\\s+$"</span>, <span class="hljs-string">""</span>).split(<span class="hljs-string">" "</span>);

        List&lt;Integer&gt; expenditure = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();

        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) {
            <span class="hljs-type">int</span> <span class="hljs-variable">expenditureItem</span> <span class="hljs-operator">=</span> Integer.parseInt(expenditureTemp[i]);
            expenditure.add(expenditureItem);
        }

        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Result.activityNotifications(expenditure, d);

        bufferedWriter.write(String.valueOf(result));
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}</code></pre></div>
<p><strong>Sample Input</strong></p>
<pre style="background:linear-gradient(to right, #F3F7EC, white);color:#3F4E4F;padding:5px" class="jop-noMdConv">
9 5                 
2 3 4 2 3 6 8 4 5
</pre>
<p><strong>Sample Output</strong></p>
<pre style="background:linear-gradient(to right, #FFE6E6, white);color:#3F4E4F;padding:5px" class="jop-noMdConv">
2
</pre>
<h2 id="elucidation">Elucidation</h2>
<p>The code provided is a Java implementation of a function called <code>activityNotifications</code> in the <code>Result</code> class. This function calculates the number of notifications that should be sent based on a set of expenditures and a given window size <code>d</code>. Here is a detailed explanation of the code:</p>
<ol>
<li>
<p><strong><code>activityNotifications</code> Method</strong>:</p>
<ul>
<li>This method is the main function that calculates the number of notifications to be sent.</li>
<li>It takes two parameters: <code>expenditure</code>, a list of expenditures, and <code>d</code>, the window size.</li>
<li>The method initializes variables, including <code>count</code> to store the notification count and <code>freq</code> to keep track of the frequency of expenditures.</li>
<li>It then calls two helper methods: <code>initializeFrequency</code> to set up the initial frequency array and <code>calculateNotifications</code> to determine the number of notifications.</li>
<li>Any exceptions that occur during the process are caught and handled with an error message.</li>
</ul>
</li>
<li>
<p><strong><code>initializeFrequency</code> Method</strong>:</p>
<ul>
<li>This method initializes the frequency array <code>freq</code> based on the initial <code>d</code> expenditures.</li>
<li>It loops through the first <code>d</code> expenditures and increments the corresponding frequency in the array.</li>
</ul>
</li>
<li>
<p><strong><code>calculateNotifications</code> Method</strong>:</p>
<ul>
<li>This method calculates the number of notifications based on median comparison.</li>
<li>It iterates through the expenditures starting from index <code>d</code>.</li>
<li>For each iteration, it calculates the median using the <code>calculateMedian</code> method and compares the current expenditure with double the median.</li>
<li>If the expenditure is greater than or equal to twice the median, it increments the <code>count</code> variable.</li>
<li>It updates the frequency array for the sliding window by removing the oldest expenditure and adding the new one.</li>
</ul>
</li>
<li>
<p><strong><code>calculateMedian</code> Method</strong>:</p>
<ul>
<li>This method calculates the median based on the frequency array <code>freq</code> and the window size <code>d</code>.</li>
<li>It handles both odd and even window sizes to determine the median value.</li>
<li>For an odd window size, it finds the middle value where the cumulative sum reaches <code>d/2 + 1</code>.</li>
<li>For an even window size, it finds the two middle values and calculates the average as the median.</li>
</ul>
</li>
</ol>
<p>Overall, the code structure is well-organized with separate methods for initialization, median calculation, and notification calculation. It efficiently handles the processing of expenditures and sliding windows to determine the number of notifications to be sent. The try-catch blocks ensure proper error handling during the execution of the function.</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Code Analysis of HR Queen's Attack II problem solution]]></title>
            <guid>b6316c68c275415a84854eda84032638</guid>
            <pubDate>Wed, 03 Jul 2024 10:17:35 GMT</pubDate>
            <content:encoded><![CDATA[<p>Given the solution code :</p>
<div><pre class="hljs"><code><span class="hljs-keyword">import</span> java.io.*;
<span class="hljs-keyword">import</span> java.math.*;
<span class="hljs-keyword">import</span> java.security.*;
<span class="hljs-keyword">import</span> java.text.*;
<span class="hljs-keyword">import</span> java.util.*;
<span class="hljs-keyword">import</span> java.util.concurrent.*;
<span class="hljs-keyword">import</span> java.util.function.*;
<span class="hljs-keyword">import</span> java.util.regex.*;
<span class="hljs-keyword">import</span> java.util.stream.*;
<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.util.stream.Collectors.joining;
<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.util.stream.Collectors.toList;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Result</span> {

    <span class="hljs-comment">/*
     * Complete the 'queensAttack' function below.
     *
     * The function is expected to return an INTEGER.
     * The function accepts following parameters:
     *  1. INTEGER n
     *  2. INTEGER k
     *  3. INTEGER r_q
     *  4. INTEGER c_q
     *  5. 2D_INTEGER_ARRAY obstacles
     */</span>

    <span class="hljs-comment">// Variable to store the total number of cells consumed</span>
    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">cellConsume</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;

    <span class="hljs-comment">// Method to calculate the queen's attack</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">queensAttack</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> r_q, <span class="hljs-type">int</span> c_q, List&lt;List&lt;Integer&gt;&gt; obstacles)</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// Convert obstacles into a map for efficient lookup</span>
            HashMap&lt;Integer, List&lt;Integer&gt;&gt; obstaclesMap = convertObstaclesIntoMap(obstacles);

            <span class="hljs-comment">// Check for obstacles in different directions</span>
            leftIteration(r_q, c_q, obstaclesMap);
            bottomIteration(r_q, c_q, obstaclesMap);
            southWestIteration(r_q, c_q, obstaclesMap);
            northWestIteration(r_q, c_q, n, obstaclesMap);
            topIteration(r_q, c_q, n, obstaclesMap);
            northEastIteration(r_q, c_q, n, obstaclesMap);
            rightIteration(r_q, c_q, n, obstaclesMap);
            southEastIteration(r_q, c_q, n, obstaclesMap);
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-comment">// Handle any exceptions that occur during the process</span>
            System.out.println(<span class="hljs-string">"An error occurred: "</span> + e.getMessage());
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">return</span> cellConsume;
    }

    <span class="hljs-comment">// Method to convert obstacles into a map for efficient lookup</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> HashMap&lt;Integer, List&lt;Integer&gt;&gt; <span class="hljs-title function_">convertObstaclesIntoMap</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; obstacles)</span> {
        <span class="hljs-comment">// Initialize a HashMap to store obstacles for efficient lookup</span>
        HashMap&lt;Integer, List&lt;Integer&gt;&gt; obstaclesMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();

        <span class="hljs-comment">// Iterate through the list of obstacles to populate the map</span>
        obstacles.forEach(x -&gt; {
            obstaclesMap.compute(x.get(<span class="hljs-number">0</span>), (k, existingList) -&gt; {
                <span class="hljs-comment">// If the key is not present, create a new list with the obstacle column value</span>
                <span class="hljs-keyword">if</span> (existingList == <span class="hljs-literal">null</span>) {
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Collections.singletonList(x.get(<span class="hljs-number">1</span>)));
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-comment">// If the key exists, add the obstacle column value to the existing list</span>
                    existingList.add(x.get(<span class="hljs-number">1</span>));
                    <span class="hljs-keyword">return</span> existingList;
                }
            });
        });

        <span class="hljs-keyword">return</span> obstaclesMap;
    }

    <span class="hljs-comment">// Method to check for obstacles in the left direction</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">leftIteration</span><span class="hljs-params">(<span class="hljs-type">int</span> r_q, <span class="hljs-type">int</span> c_q, HashMap&lt;Integer, List&lt;Integer&gt;&gt; obstacles)</span> {
        <span class="hljs-comment">// Iterate to the left from the queen's position</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> r_q, c = c_q - <span class="hljs-number">1</span>; c &gt;= <span class="hljs-number">1</span>; c--) {
            <span class="hljs-comment">// Check if there is an obstacle at the current position</span>
            <span class="hljs-keyword">if</span> (obstacles.get(r) != <span class="hljs-literal">null</span> &amp;&amp; obstacles.get(r).contains(c)) {
                <span class="hljs-comment">// If obstacle is present, stop further iteration in this direction</span>
                <span class="hljs-keyword">return</span>;
            }
            <span class="hljs-comment">// Increment the total cells consumed</span>
            cellConsume++;
        }
    }

    <span class="hljs-comment">// Method to check for obstacles in the bottom direction</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bottomIteration</span><span class="hljs-params">(<span class="hljs-type">int</span> r_q, <span class="hljs-type">int</span> c_q, Map&lt;Integer, List&lt;Integer&gt;&gt; obstacles)</span> {
        <span class="hljs-comment">// Iterate from the queen's position downwards</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> r_q - <span class="hljs-number">1</span>, c = c_q; r &gt;= <span class="hljs-number">1</span>; r--) {
            <span class="hljs-comment">// Check if there is an obstacle at the current position</span>
            <span class="hljs-keyword">if</span> (obstacles.get(r) != <span class="hljs-literal">null</span> &amp;&amp; obstacles.get(r).contains(c)) {
                <span class="hljs-comment">// If obstacle is present, stop further iteration in this direction</span>
                <span class="hljs-keyword">return</span>;
            }
            <span class="hljs-comment">// Increment the total cells consumed</span>
            cellConsume++;
        }
    }

    <span class="hljs-comment">// Method to check for obstacles in the southwest direction</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">southWestIteration</span><span class="hljs-params">(<span class="hljs-type">int</span> r_q, <span class="hljs-type">int</span> c_q, HashMap&lt;Integer, List&lt;Integer&gt;&gt; obstacles)</span> {
        <span class="hljs-comment">// Iterate diagonally towards the southwest direction</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> r_q - <span class="hljs-number">1</span>, c = c_q - <span class="hljs-number">1</span>; r &gt;= <span class="hljs-number">1</span> &amp;&amp; c &gt;= <span class="hljs-number">1</span>; r--, c--) {
            <span class="hljs-comment">// Check for obstacles at the current diagonal position</span>
            <span class="hljs-keyword">if</span> (obstacles.get(r) != <span class="hljs-literal">null</span> &amp;&amp; obstacles.get(r).contains(c)) {
                <span class="hljs-comment">// If obstacle is present, stop further iteration in this direction</span>
                <span class="hljs-keyword">return</span>;
            }
            <span class="hljs-comment">// Increment the total cells consumed</span>
            cellConsume++;
        }
    }

    <span class="hljs-comment">// Method to check for obstacles in the northwest direction</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">northWestIteration</span><span class="hljs-params">(<span class="hljs-type">int</span> r_q, <span class="hljs-type">int</span> c_q, <span class="hljs-type">int</span> n, HashMap&lt;Integer, List&lt;Integer&gt;&gt; obstacles)</span> {
        <span class="hljs-comment">// Iterate diagonally towards the northwest direction</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> r_q + <span class="hljs-number">1</span>, c = c_q - <span class="hljs-number">1</span>; r &lt;= n &amp;&amp; c &gt;= <span class="hljs-number">1</span>; r++, c--) {
            <span class="hljs-comment">// Check for obstacles at the current diagonal position</span>
            <span class="hljs-keyword">if</span> (obstacles.get(r) != <span class="hljs-literal">null</span> &amp;&amp; obstacles.get(r).contains(c)) {
                <span class="hljs-comment">// If obstacle is present, stop further iteration in this direction</span>
                <span class="hljs-keyword">return</span>;
            }
            <span class="hljs-comment">// Increment the total cells consumed</span>
            cellConsume++;
        }
    }

    <span class="hljs-comment">// Method to check for obstacles in the top direction</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">topIteration</span><span class="hljs-params">(<span class="hljs-type">int</span> r_q, <span class="hljs-type">int</span> c_q, <span class="hljs-type">int</span> n, HashMap&lt;Integer, List&lt;Integer&gt;&gt; obstacles)</span> {
        <span class="hljs-comment">// Iterate upwards from the queen's position</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> r_q + <span class="hljs-number">1</span>, c = c_q; r &lt;= n; r++) {
            <span class="hljs-comment">// Check if there is an obstacle at the current position</span>
            <span class="hljs-keyword">if</span> (obstacles.get(r) != <span class="hljs-literal">null</span> &amp;&amp; obstacles.get(r).contains(c)) {
                <span class="hljs-comment">// If obstacle is present, stop further iteration in this direction</span>
                <span class="hljs-keyword">return</span>;
            }
            <span class="hljs-comment">// Increment the total cells consumed</span>
            cellConsume++;
        }
    }

    <span class="hljs-comment">// Method to check for obstacles in the northeast direction</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">northEastIteration</span><span class="hljs-params">(<span class="hljs-type">int</span> r_q, <span class="hljs-type">int</span> c_q, <span class="hljs-type">int</span> n, HashMap&lt;Integer, List&lt;Integer&gt;&gt; obstacles)</span> {
        <span class="hljs-comment">// Iterate diagonally towards the northeast direction</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> r_q + <span class="hljs-number">1</span>, c = c_q + <span class="hljs-number">1</span>; r &lt;= n &amp;&amp; c &lt;= n; r++, c++) {
            <span class="hljs-comment">// Check for obstacles at the current diagonal position</span>
            <span class="hljs-keyword">if</span> (obstacles.get(r) != <span class="hljs-literal">null</span> &amp;&amp; obstacles.get(r).contains(c)) {
                <span class="hljs-comment">// If obstacle is present, stop further iteration in this direction</span>
                <span class="hljs-keyword">return</span>;
            }
            <span class="hljs-comment">// Increment the total cells consumed</span>
            cellConsume++;
        }
    }

    <span class="hljs-comment">// Method to check for obstacles in the right direction</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rightIteration</span><span class="hljs-params">(<span class="hljs-type">int</span> r_q, <span class="hljs-type">int</span> c_q, <span class="hljs-type">int</span> n, HashMap&lt;Integer, List&lt;Integer&gt;&gt; obstacles)</span> {
        <span class="hljs-comment">// Iterate to the right from the queen's position</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> r_q, c = c_q + <span class="hljs-number">1</span>; c &lt;= n; c++) {
            <span class="hljs-comment">// Check if there is an obstacle at the current position</span>
            <span class="hljs-keyword">if</span> (obstacles.get(r) != <span class="hljs-literal">null</span> &amp;&amp; obstacles.get(r).contains(c)) {
                <span class="hljs-comment">// If obstacle is present, stop further iteration in this direction</span>
                <span class="hljs-keyword">return</span>;
            }
            <span class="hljs-comment">// Increment the total cells consumed</span>
            cellConsume++;
        }
    }

    <span class="hljs-comment">// Method to check for obstacles in the southeast direction</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">southEastIteration</span><span class="hljs-params">(<span class="hljs-type">int</span> r_q, <span class="hljs-type">int</span> c_q, <span class="hljs-type">int</span> n, HashMap&lt;Integer, List&lt;Integer&gt;&gt; obstacles)</span> {
        <span class="hljs-comment">// Iterate diagonally towards the southeast direction</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> r_q - <span class="hljs-number">1</span>, c = c_q + <span class="hljs-number">1</span>; r &gt;= <span class="hljs-number">1</span> &amp;&amp; c &lt;= n; r--, c++) {
            <span class="hljs-comment">// Check for obstacles at the current diagonal position</span>
            <span class="hljs-keyword">if</span> (obstacles.get(r) != <span class="hljs-literal">null</span> &amp;&amp; obstacles.get(r).contains(c)) {
                <span class="hljs-comment">// If obstacle is present, stop further iteration in this direction</span>
                <span class="hljs-keyword">return</span>;
            }
            <span class="hljs-comment">// Increment the total cells consumed</span>
            cellConsume++;
        }
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException {
        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));
        <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bufferedWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(System.getenv(<span class="hljs-string">"OUTPUT_PATH"</span>)));

        String[] firstMultipleInput = bufferedReader.readLine().replaceAll(<span class="hljs-string">"\\s+$"</span>, <span class="hljs-string">""</span>).split(<span class="hljs-string">" "</span>);

        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> Integer.parseInt(firstMultipleInput[<span class="hljs-number">0</span>]);

        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> Integer.parseInt(firstMultipleInput[<span class="hljs-number">1</span>]);

        String[] secondMultipleInput = bufferedReader.readLine().replaceAll(<span class="hljs-string">"\\s+$"</span>, <span class="hljs-string">""</span>).split(<span class="hljs-string">" "</span>);

        <span class="hljs-type">int</span> <span class="hljs-variable">r_q</span> <span class="hljs-operator">=</span> Integer.parseInt(secondMultipleInput[<span class="hljs-number">0</span>]);

        <span class="hljs-type">int</span> <span class="hljs-variable">c_q</span> <span class="hljs-operator">=</span> Integer.parseInt(secondMultipleInput[<span class="hljs-number">1</span>]);

        List&lt;List&lt;Integer&gt;&gt; obstacles = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();

        IntStream.range(<span class="hljs-number">0</span>, k).forEach(i -&gt; {
            <span class="hljs-keyword">try</span> {
                obstacles.add(
                    Stream.of(bufferedReader.readLine().replaceAll(<span class="hljs-string">"\\s+$"</span>, <span class="hljs-string">""</span>).split(<span class="hljs-string">" "</span>))
                        .map(Integer::parseInt)
                        .collect(toList())
                );
            } <span class="hljs-keyword">catch</span> (IOException ex) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(ex);
            }
        });

        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Result.queensAttack(n, k, r_q, c_q, obstacles);

        bufferedWriter.write(String.valueOf(result));
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}</code></pre></div>
<p><strong>Sample Input</strong></p>
<pre style="background:linear-gradient(to right, #F3F7EC, white);color:#3F4E4F;padding:5px" class="jop-noMdConv">
4 0
4 4
</pre>
<p><strong>Sample Output</strong></p>
<pre style="background:linear-gradient(to right, #FFE6E6, white);color:#3F4E4F;padding:5px" class="jop-noMdConv">
9
</pre>
<h2 id="elucidation">Elucidation</h2>
<p>Here is a detailed explanation of the provided code:</p>
<ol>
<li>
<p><strong>Result Class</strong>:</p>
<ul>
<li>The <code>Result</code> class contains methods to calculate the queen’s attack in different directions and handle obstacles efficiently.</li>
<li>It uses a static variable <code>cellConsume</code> to store the total number of cells consumed during the queen’s attack.</li>
<li>The <code>queensAttack</code> method is the main method that orchestrates the calculation of the queen’s attack in various directions.</li>
<li>It converts the obstacles into a map for efficient lookup and then checks for obstacles in different directions using separate methods.</li>
<li>Each direction checking method increments the <code>cellConsume</code> counter based on the number of cells consumed.</li>
<li>The <code>queensAttack</code> method returns the total <code>cellConsume</code> count after calculating the queen’s attack.</li>
</ul>
</li>
<li>
<p><strong>Solution Class</strong>:</p>
<ul>
<li>The <code>Solution</code> class contains the <code>main</code> method, which is the entry point of the program.</li>
<li>It reads input from the standard input (console) to get the board size, queen’s position, and obstacles.</li>
<li>The obstacles are stored in a list of lists representing their positions on the board.</li>
<li>The <code>queensAttack</code> method from the <code>Result</code> class is called to calculate the total number of cells consumed during the queen’s attack.</li>
<li>The result is written to the standard output (console) using a <code>BufferedWriter</code>.</li>
</ul>
</li>
</ol>
<p>Overall, the code efficiently calculates the queen’s attack by considering obstacles in different directions and provides the total number of cells consumed during the attack. The code structure separates the logic into distinct methods for better readability and maintainability.</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Code Analysis of HR Candies problem solution]]></title>
            <guid>776aded309ab4d28b8e9749a8e2aee0b</guid>
            <pubDate>Wed, 03 Jul 2024 09:23:26 GMT</pubDate>
            <content:encoded><![CDATA[<p>Given the solution code :</p>
<div><pre class="hljs"><code><span class="hljs-keyword">import</span> java.io.*;
<span class="hljs-keyword">import</span> java.math.*;
<span class="hljs-keyword">import</span> java.security.*;
<span class="hljs-keyword">import</span> java.text.*;
<span class="hljs-keyword">import</span> java.util.*;
<span class="hljs-keyword">import</span> java.util.concurrent.*;
<span class="hljs-keyword">import</span> java.util.regex.*;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Result</span> {

    <span class="hljs-comment">/*
     * Complete the 'candies' function below.
     *
     * The function is expected to return a LONG_INTEGER.
     * The function accepts following parameters:
     *  1. INTEGER n
     *  2. INTEGER_ARRAY arr
     */</span>

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">candies</span><span class="hljs-params">(<span class="hljs-type">int</span> n, List&lt;Integer&gt; arr)</span> {
        <span class="hljs-comment">// Initialize variables for streaks and total candies</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">streakUp</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, streakDown = <span class="hljs-number">1</span>, lastStreakUp = <span class="hljs-number">1</span>;
        <span class="hljs-type">long</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; 

        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// Iterate through the array</span>
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n-<span class="hljs-number">1</span>; i++){            
                <span class="hljs-comment">// Check if the current element is greater than the next element</span>
                <span class="hljs-keyword">if</span>(arr.get(i) &gt; arr.get(i+<span class="hljs-number">1</span>)){                    
                    streakDown++;                            
                    <span class="hljs-keyword">if</span>(lastStreakUp &gt; streakDown-<span class="hljs-number">1</span>){                            
                        total += streakDown-<span class="hljs-number">1</span>;                                    
                    } <span class="hljs-keyword">else</span> { 
                        total += streakDown;
                    }                                
                    streakUp = <span class="hljs-number">1</span>;
                }                        
                <span class="hljs-comment">// Check if the current element is less than the next element</span>
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr.get(i) &lt; arr.get(i+<span class="hljs-number">1</span>)){                        
                    streakUp++;
                    streakDown = <span class="hljs-number">1</span>;
                    total += streakUp;
                    lastStreakUp = streakUp;                                
                }
                <span class="hljs-comment">// Handle the case when the elements are equal</span>
                <span class="hljs-keyword">else</span> {                    
                    streakUp = streakDown = lastStreakUp = <span class="hljs-number">1</span>;
                    total++;                            
                }
            }
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-comment">// Handle any exceptions that occur during the process</span>
            System.out.println(<span class="hljs-string">"An error occurred: "</span> + e.getMessage());
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
        }

        <span class="hljs-keyword">return</span> total;
    }

}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException {
        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));
        <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bufferedWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(System.getenv(<span class="hljs-string">"OUTPUT_PATH"</span>)));

        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> Integer.parseInt(bufferedReader.readLine().trim());

        List&lt;Integer&gt; arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();

        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) {
            <span class="hljs-type">int</span> <span class="hljs-variable">arrItem</span> <span class="hljs-operator">=</span> Integer.parseInt(bufferedReader.readLine().trim());
            arr.add(arrItem);
        }

        <span class="hljs-type">long</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Result.candies(n, arr);

        bufferedWriter.write(String.valueOf(result));
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}</code></pre></div>
<p><strong>Sample Input</strong></p>
<pre style="background:linear-gradient(to right, #F3F7EC, white);color:#3F4E4F;padding:5px" class="jop-noMdConv">
3
1
2
2
</pre>
<p><strong>Sample Output</strong></p>
<pre style="background:linear-gradient(to right, #FFE6E6, white);color:#3F4E4F;padding:5px" class="jop-noMdConv">
4
</pre>
<h2 id="elucidation">Elucidation</h2>
<ol>
<li>
<p><strong>Result Class</strong>:</p>
<ul>
<li>The <code>Result</code> class contains a static method <code>candies</code> that calculates the total number of candies to be distributed based on the given array of ratings.</li>
<li>The method takes two parameters: <code>n</code> (the number of elements in the array) and <code>arr</code> (the list of ratings).</li>
<li>It initializes variables for streaks of increasing and decreasing ratings, along with the total number of candies.</li>
<li>The method iterates through the array to calculate the total number of candies based on the streaks of ratings.</li>
<li>It handles cases where the current rating is greater than, less than, or equal to the next rating.</li>
<li>The method uses try-catch blocks to handle any exceptions that may occur during the process.</li>
</ul>
</li>
<li>
<p><strong>Solution Class</strong>:</p>
<ul>
<li>The <code>Solution</code> class contains the <code>main</code> method, which is the entry point of the program.</li>
<li>It reads input from the standard input (console) using a <code>BufferedReader</code> and parses the input to get the number of elements <code>n</code> and the list of ratings <code>arr</code>.</li>
<li>The ratings are stored in an <code>ArrayList</code>.</li>
<li>The <code>candies</code> method from the <code>Result</code> class is called to calculate the total number of candies based on the ratings.</li>
<li>The result is written to the standard output (console) using a <code>BufferedWriter</code>.</li>
</ul>
</li>
</ol>
<p>Overall, the code structure separates the logic for calculating candies into the <code>Result</code> class and handles input/output operations in the <code>Solution</code> class. The <code>candies</code> method efficiently calculates the total number of candies based on the streaks of increasing and decreasing ratings in the input array. The <code>main</code> method reads input, processes it, and writes the result to the output.</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Code Analysis of HR Goodland Electricity problem solution]]></title>
            <guid>326bba3fc113446e829114782bb534bc</guid>
            <pubDate>Wed, 03 Jul 2024 07:15:22 GMT</pubDate>
            <content:encoded><![CDATA[<p>Given the solution code :</p>
<div><pre class="hljs"><code><span class="hljs-keyword">import</span> java.io.*;
<span class="hljs-keyword">import</span> java.math.*;
<span class="hljs-keyword">import</span> java.security.*;
<span class="hljs-keyword">import</span> java.text.*;
<span class="hljs-keyword">import</span> java.util.*;
<span class="hljs-keyword">import</span> java.util.concurrent.*;
<span class="hljs-keyword">import</span> java.util.regex.*;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Result</span> {

    <span class="hljs-comment">/*
     * Complete the 'pylons' function below.
     *
     * The function is expected to return an INTEGER.
     * The function accepts following parameters:
     *  1. INTEGER k
     *  2. INTEGER_ARRAY arr
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pylons</span><span class="hljs-params">(<span class="hljs-type">int</span> k, List&lt;Integer&gt; arr)</span> {
        <span class="hljs-comment">// Initialize count of pylons</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
        <span class="hljs-comment">// Initialize the previous pylon location</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">prevLoc</span> <span class="hljs-operator">=</span> -k;        

        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// Iterate through the array</span>
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;arr.size(); i++){
                <span class="hljs-comment">// Calculate the maximum coverage range</span>
                <span class="hljs-type">int</span> <span class="hljs-variable">maxCoverage</span> <span class="hljs-operator">=</span> prevLoc+k;

                <span class="hljs-comment">// Skip if within the coverage range</span>
                <span class="hljs-keyword">if</span>(i &lt; maxCoverage)
                    <span class="hljs-keyword">continue</span>;

                <span class="hljs-comment">// Search for pylons within the coverage range</span>
                <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Math.min(arr.size()-<span class="hljs-number">1</span>, i+k-<span class="hljs-number">1</span>);
                <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">0</span>, i-(k-<span class="hljs-number">1</span>));
                <span class="hljs-type">int</span> <span class="hljs-variable">pylonIndex</span> <span class="hljs-operator">=</span> findPylonInRange(arr, max, min);

                <span class="hljs-comment">// If a pylon is found, update count and previous location</span>
                <span class="hljs-keyword">if</span> (pylonIndex != -<span class="hljs-number">1</span>) {
                    count++;
                    prevLoc = pylonIndex;
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-comment">// If no pylon is found, return -1</span>
                    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
                }
            }
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-comment">// Handle any exceptions that occur during the process</span>
            System.out.println(<span class="hljs-string">"An error occurred: "</span> + e.getMessage());
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
        }

        <span class="hljs-keyword">return</span> count;
    }

    <span class="hljs-comment">// Method to find a pylon within the specified range</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findPylonInRange</span><span class="hljs-params">(List&lt;Integer&gt; arr, <span class="hljs-type">int</span> max, <span class="hljs-type">int</span> min)</span> {
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=max; j&gt;=min; j--){
            <span class="hljs-keyword">if</span>(arr.get(j) == <span class="hljs-number">1</span>){
                <span class="hljs-keyword">return</span> j;
            }
        }
        <span class="hljs-comment">// Return -1 if no pylon is found within the range</span>
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }

}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException {
        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));
        <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bufferedWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(System.getenv(<span class="hljs-string">"OUTPUT_PATH"</span>)));

        String[] firstMultipleInput = bufferedReader.readLine().replaceAll(<span class="hljs-string">"\\s+$"</span>, <span class="hljs-string">""</span>).split(<span class="hljs-string">" "</span>);

        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> Integer.parseInt(firstMultipleInput[<span class="hljs-number">0</span>]);

        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> Integer.parseInt(firstMultipleInput[<span class="hljs-number">1</span>]);

        String[] arrTemp = bufferedReader.readLine().replaceAll(<span class="hljs-string">"\\s+$"</span>, <span class="hljs-string">""</span>).split(<span class="hljs-string">" "</span>);

        List&lt;Integer&gt; arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();

        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) {
            <span class="hljs-type">int</span> <span class="hljs-variable">arrItem</span> <span class="hljs-operator">=</span> Integer.parseInt(arrTemp[i]);
            arr.add(arrItem);
        }

        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Result.pylons(k, arr);

        bufferedWriter.write(String.valueOf(result));
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}</code></pre></div>
<p><strong>Sample Input</strong></p>
<pre style="background:linear-gradient(to right, #F3F7EC, white);color:#3F4E4F;padding:5px" class="jop-noMdConv">
6 2           
0 1 1 1 1 0
</pre>
<p><strong>Sample Output</strong></p>
<pre style="background:linear-gradient(to right, #FFE6E6, white);color:#3F4E4F;padding:5px" class="jop-noMdConv">
2
</pre>
<h2 id="elucidation">Elucidation</h2>
<ol>
<li>
<p><strong>pylons Method</strong>:</p>
<ul>
<li>The <code>pylons</code> method takes two parameters: <code>k</code> (an integer representing the coverage range) and <code>arr</code> (a list of integers representing the presence of pylons).</li>
<li>It initializes the count of pylons (<code>count</code>) to 0 and the previous pylon location (<code>prevLoc</code>) to a value before the start of the array.</li>
<li>The method uses a try-catch block to handle any exceptions that may occur during the process.</li>
<li>It iterates through the array to find pylons within the coverage range.</li>
<li>If a pylon is found within the range, the count is incremented, and the previous location is updated.</li>
<li>If no pylon is found within the range, the method returns -1.</li>
</ul>
</li>
<li>
<p><strong>findPylonInRange Method</strong>:</p>
<ul>
<li>The <code>findPylonInRange</code> method takes three parameters: <code>arr</code> (the list of integers representing pylons), <code>max</code> (the maximum index to search), and <code>min</code> (the minimum index to search).</li>
<li>It iterates through the array from the maximum index to the minimum index to find a pylon.</li>
<li>If a pylon is found, it returns the index of the pylon. Otherwise, it returns -1.</li>
</ul>
</li>
</ol>
<p>Overall, the <code>pylons</code> method efficiently searches for pylons within the specified coverage range by breaking down the process into smaller methods and handling exceptions gracefully. The <code>findPylonInRange</code> method simplifies the search for pylons within a specific range, improving the readability and maintainability of the code.</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Code Analysis of HR Crossword Puzzle problem solution]]></title>
            <guid>e062ed7284394371b1e0a630286cdcd4</guid>
            <pubDate>Wed, 03 Jul 2024 05:35:27 GMT</pubDate>
            <content:encoded><![CDATA[<p>Given the solution code :</p>
<div><pre class="hljs"><code><span class="hljs-keyword">import</span> java.io.*;
<span class="hljs-keyword">import</span> java.math.*;
<span class="hljs-keyword">import</span> java.security.*;
<span class="hljs-keyword">import</span> java.text.*;
<span class="hljs-keyword">import</span> java.util.*;
<span class="hljs-keyword">import</span> java.util.concurrent.*;
<span class="hljs-keyword">import</span> java.util.regex.*;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Result</span> {

    <span class="hljs-keyword">static</span> List&lt;String&gt; result;
    <span class="hljs-comment">/*
     * Complete the 'crosswordPuzzle' function below.
     *
     * The function is expected to return a STRING_ARRAY.
     * The function accepts following parameters:
     *  1. STRING_ARRAY crossword
     *  2. STRING words
     */</span>    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title function_">crosswordPuzzle</span><span class="hljs-params">(List&lt;String&gt; crossword, String words)</span> {
        <span class="hljs-comment">// Function to solve the crossword puzzle</span>
        result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">// Initialize the result to store the solved puzzle</span>
        <span class="hljs-type">char</span>[][] croswrd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>]; <span class="hljs-comment">// Create a 10x10 crossword grid</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
        <span class="hljs-comment">// Populate the crossword grid with characters from the input</span>
        <span class="hljs-keyword">for</span> (String s : crossword) {
            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : s.toCharArray()) {
                croswrd[i][j] = ch;
                j++;
            }
            i++;
        }
        <span class="hljs-keyword">try</span> {
            helper(croswrd, words.split(<span class="hljs-string">";"</span>), <span class="hljs-number">0</span>); <span class="hljs-comment">// Call the helper function to solve the puzzle</span>
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-comment">// Handle any exceptions that occur during the solving process</span>
            System.out.println(<span class="hljs-string">"An error occurred: "</span> + e.getMessage());
        }
        <span class="hljs-keyword">return</span> result; <span class="hljs-comment">// Return the solved crossword puzzle</span>
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] c, String[] words, <span class="hljs-type">int</span> vidx)</span> {
        <span class="hljs-comment">// Recursive helper function to solve the crossword puzzle</span>
        <span class="hljs-keyword">if</span> (vidx == words.length) {
            <span class="hljs-comment">// If all words are placed, convert the crossword grid to a list of strings</span>
            List&lt;String&gt; temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span>[] str : c) {
                <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">""</span>;
                <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : str) {
                    s += ch;
                }
                temp.add(s);
            }
            result = temp; <span class="hljs-comment">// Update the result with the solved puzzle</span>
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-type">String</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> words[vidx]; <span class="hljs-comment">// Get the current word to be placed</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">9</span>; i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">9</span>; j++) {
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-comment">// Try placing the word horizontally if possible</span>
                    <span class="hljs-keyword">if</span> (canPutHorizontally(c, word, i, j)) {
                        <span class="hljs-type">boolean</span>[][] vis = putHorizontally(c, word, i, j); <span class="hljs-comment">// Track the placement</span>
                        helper(c, words, vidx + <span class="hljs-number">1</span>); <span class="hljs-comment">// Recursively call helper for the next word</span>
                        replaceHorizontal(c, word, vis, i, j); <span class="hljs-comment">// Backtrack and replace if needed</span>
                    }

                    <span class="hljs-comment">// Try placing the word vertically if possible</span>
                    <span class="hljs-keyword">if</span> (canPutVertically(c, word, i, j)) {
                        <span class="hljs-type">boolean</span>[][] vis = putVertically(c, word, i, j); <span class="hljs-comment">// Track the placement</span>
                        helper(c, words, vidx + <span class="hljs-number">1</span>); <span class="hljs-comment">// Recursively call helper for the next word</span>
                        replaceVertical(c, word, vis, i, j); <span class="hljs-comment">// Backtrack and replace if needed</span>
                    }
                } <span class="hljs-keyword">catch</span> (Exception e) {
                    System.out.println(<span class="hljs-string">"An error occurred: "</span> + e.getMessage());
                }
            }
        }
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">replaceHorizontal</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] c, String word, <span class="hljs-type">boolean</span>[][] vis, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// Replace the characters in the horizontal direction for the word</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; word.length(); k++) {
                <span class="hljs-keyword">if</span> (vis[i][j + k]) {
                    <span class="hljs-comment">// Replace the character with a dash and update the visibility array</span>
                    c[i][j + k] = <span class="hljs-string">'-'</span>;
                    vis[i][j + k] = <span class="hljs-literal">false</span>;
                }
            }
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-comment">// Handle any exceptions that occur during horizontal replacement</span>
            System.out.println(<span class="hljs-string">"An error occurred in replaceHorizontal: "</span> + e.getMessage());
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">replaceVertical</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] c, String word, <span class="hljs-type">boolean</span>[][] vis, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// Replace the characters in the vertical direction for the word</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; word.length(); k++) {
                <span class="hljs-keyword">if</span> (vis[i + k][j]) {
                    <span class="hljs-comment">// Replace the character with a dash and update the visibility array</span>
                    c[i + k][j] = <span class="hljs-string">'-'</span>;
                    vis[i + k][j] = <span class="hljs-literal">false</span>;
                }
            }
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-comment">// Handle any exceptions that occur during vertical replacement</span>
            System.out.println(<span class="hljs-string">"An error occurred in replaceVertical: "</span> + e.getMessage());
        }
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span>[][] putHorizontally(<span class="hljs-type">char</span>[][] c, String word, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j) {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// Create a boolean array to track the placement of characters for the word horizontally</span>
            <span class="hljs-type">boolean</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; word.length(); k++) {
                <span class="hljs-comment">// Check if it's within the bounds and the current position is empty</span>
                <span class="hljs-keyword">if</span> (j + k &lt; <span class="hljs-number">10</span> &amp;&amp; c[i][j + k] == <span class="hljs-string">'-'</span>) {
                    <span class="hljs-comment">// Place the character from the word at the corresponding position</span>
                    c[i][j + k] = word.charAt(k);
                    res[i][j + k] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// Update the tracking array</span>
                }
            }
            <span class="hljs-keyword">return</span> res; <span class="hljs-comment">// Return the tracking array</span>
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-comment">// Handle any exceptions that occur during the horizontal placement</span>
            System.out.println(<span class="hljs-string">"An error occurred in putHorizontally: "</span> + e.getMessage());
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>]; <span class="hljs-comment">// Return an empty tracking array</span>
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span>[][] putVertically(<span class="hljs-type">char</span>[][] c, String word, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j) {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// Create a boolean array to track the placement of characters for the word vertically</span>
            <span class="hljs-type">boolean</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; word.length(); k++) {
                <span class="hljs-comment">// Check if it's within the bounds and the current position is empty</span>
                <span class="hljs-keyword">if</span> (i + k &lt; <span class="hljs-number">10</span> &amp;&amp; c[i + k][j] == <span class="hljs-string">'-'</span>) {
                    <span class="hljs-comment">// Place the character from the word at the corresponding position</span>
                    c[i + k][j] = word.charAt(k);
                    res[i + k][j] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// Update the tracking array</span>
                }
            }
            <span class="hljs-keyword">return</span> res; <span class="hljs-comment">// Return the tracking array</span>
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-comment">// Handle any exceptions that occur during the vertical placement</span>
            System.out.println(<span class="hljs-string">"An error occurred in putVertically: "</span> + e.getMessage());
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>]; <span class="hljs-comment">// Return an empty tracking array</span>
        }
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canPutHorizontally</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] c, String word, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// Check if the word can be placed horizontally at position i, j on the crossword</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; word.length(); k++) {
                <span class="hljs-keyword">if</span> (j + k &lt; <span class="hljs-number">10</span> &amp;&amp; (c[i][j + k] == <span class="hljs-string">'-'</span> || c[i][j + k] == word.charAt(k))) {
                    <span class="hljs-comment">// Continue checking the next character in the word</span>
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-comment">// Return false if the word cannot be placed horizontally at the current position</span>
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }
            }
            <span class="hljs-comment">// Return true if the word can be placed horizontally at the given position</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-comment">// Handle any exceptions that occur during the check</span>
            System.out.println(<span class="hljs-string">"An error occurred in canPutHorizontally: "</span> + e.getMessage());
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canPutVertically</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] c, String word, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// Check if the word can be placed vertically at position i, j on the crossword</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; word.length(); k++) {
                <span class="hljs-keyword">if</span> (i + k &lt; <span class="hljs-number">10</span> &amp;&amp; (c[i + k][j] == <span class="hljs-string">'-'</span> || c[i + k][j] == word.charAt(k))) {
                    <span class="hljs-comment">// Continue checking the next character in the word</span>
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-comment">// Return false if the word cannot be placed vertically at the current position</span>
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }
            }
            <span class="hljs-comment">// Return true if the word can be placed vertically at the given position</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-comment">// Handle any exceptions that occur during the check</span>
            System.out.println(<span class="hljs-string">"An error occurred in canPutVertically: "</span> + e.getMessage());
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] c)</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// Print the crossword grid</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span>[] cc : c) {
                <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ccc : cc) {
                    System.out.print(ccc);
                }
                System.out.println();
            }
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-comment">// Handle any exceptions that occur during printing</span>
            System.out.println(<span class="hljs-string">"An error occurred in printing: "</span> + e.getMessage());
        }
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException {
        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));
        <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bufferedWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(System.getenv(<span class="hljs-string">"OUTPUT_PATH"</span>)));

        List&lt;String&gt; crossword = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();

        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
            <span class="hljs-type">String</span> <span class="hljs-variable">crosswordItem</span> <span class="hljs-operator">=</span> bufferedReader.readLine();
            crossword.add(crosswordItem);
        }

        <span class="hljs-type">String</span> <span class="hljs-variable">words</span> <span class="hljs-operator">=</span> bufferedReader.readLine();

        List&lt;String&gt; result = Result.crosswordPuzzle(crossword, words);

        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; result.size(); i++) {
            bufferedWriter.write(result.get(i));

            <span class="hljs-keyword">if</span> (i != result.size() - <span class="hljs-number">1</span>) {
                bufferedWriter.write(<span class="hljs-string">"\n"</span>);
            }
        }

        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}</code></pre></div>
<p><strong>Sample Input</strong></p>
<pre style="background:linear-gradient(to right, #F3F7EC, white);color:#3F4E4F;padding:5px" class="jop-noMdConv">
+-++++++++
+-++++++++
+-++++++++
+-----++++
+-+++-++++
+-+++-++++
+++++-++++
++------++
+++++-++++
+++++-++++
LONDON;DELHI;ICELAND;ANKARA
</pre>
<p><strong>Sample Output</strong></p>
<pre style="background:linear-gradient(to right, #FFE6E6, white);color:#3F4E4F;padding:5px" class="jop-noMdConv">
+L++++++++
+O++++++++
+N++++++++
+DELHI++++
+O+++C++++
+N+++E++++
+++++L++++
++ANKARA++
+++++N++++
+++++D++++
</pre>
<h2 id="elucidation">Elucidation</h2>
<p>The provided code is a solution to a crossword puzzle problem. Here is a detailed explanation of each section:</p>
<ol>
<li>
<p><code>Result</code> Class:</p>
<ul>
<li>This class contains static methods to solve the crossword puzzle.</li>
<li>It initializes a static List <code>result</code> to store the solved puzzle.</li>
<li>The <code>crosswordPuzzle</code> method takes a list of strings representing the crossword grid and a string of words to place in the grid.</li>
<li>It converts the input crossword grid into a 2D char array.</li>
<li>Then, it calls the <code>helper</code> method to solve the puzzle by trying to place words horizontally and vertically.</li>
<li>If an error occurs during the solving process, it catches the exception and prints an error message.</li>
<li>The class also includes helper methods like <code>replaceHorizontal</code>, <code>replaceVertical</code>, <code>putHorizontally</code>, <code>putVertically</code>, <code>canPutHorizontally</code>, <code>canPutVertically</code>, and <code>print</code> to assist in solving the puzzle.</li>
</ul>
</li>
<li>
<p><code>Solution</code> Class:</p>
<ul>
<li>The <code>main</code> method reads input from the user to populate the crossword grid and words.</li>
<li>It then calls the <code>crosswordPuzzle</code> method from the <code>Result</code> class to solve the puzzle.</li>
<li>Finally, it writes the solved puzzle to the output file.</li>
</ul>
</li>
</ol>
<p>Overall, the code structure follows a modular approach to solving the crossword puzzle problem, with separate methods for different tasks such as checking placement validity, tracking character placement, and handling exceptions.</p>
<h2 id="the-result-class">The <code>Result</code> Class</h2>
<p>The provided code is a comprehensive solution to a crossword puzzle problem. Here is a detailed explanation of each section:</p>
<ol>
<li>
<p><code>Result</code> Class:</p>
<ul>
<li>This class contains static methods to solve the crossword puzzle.</li>
<li>It initializes a static List <code>result</code> to store the solved puzzle.</li>
<li>The <code>crosswordPuzzle</code> method takes a list of strings representing the crossword grid and a string of words to place in the grid.</li>
<li>It converts the input crossword grid into a 2D char array.</li>
<li>Then, it calls the <code>helper</code> method to solve the puzzle by trying to place words horizontally and vertically.</li>
<li>If an error occurs during the solving process, it catches the exception and prints an error message.</li>
<li>The class also includes helper methods like <code>replaceHorizontal</code>, <code>replaceVertical</code>, <code>putHorizontally</code>, <code>putVertically</code>, <code>canPutHorizontally</code>, <code>canPutVertically</code>, and <code>print</code> to assist in solving the puzzle.</li>
</ul>
</li>
<li>
<p><code>helper</code> Method:</p>
<ul>
<li>This recursive method is the core of solving the crossword puzzle.</li>
<li>It iterates through each word to be placed and tries to place it horizontally and vertically in the grid.</li>
<li>If a word can be placed, it recursively calls itself for the next word.</li>
<li>It backtracks by replacing characters if needed to explore all possible placements.</li>
</ul>
</li>
<li>
<p><code>replaceHorizontal</code> and <code>replaceVertical</code> Methods:</p>
<ul>
<li>These methods are used to backtrack and replace characters in the horizontal and vertical directions, respectively.</li>
<li>They are called when a word cannot be placed successfully.</li>
</ul>
</li>
<li>
<p><code>putHorizontally</code> and <code>putVertically</code> Methods:</p>
<ul>
<li>These methods are used to track the placement of characters for words horizontally and vertically.</li>
<li>They return a boolean array to indicate the successful placement of characters.</li>
</ul>
</li>
<li>
<p><code>canPutHorizontally</code> and <code>canPutVertically</code> Methods:</p>
<ul>
<li>These methods check if a word can be placed horizontally or vertically at a specific position in the grid.</li>
<li>They validate the placement based on the characters already present in the grid.</li>
</ul>
</li>
<li>
<p><code>print</code> Method:</p>
<ul>
<li>This method is used to print the crossword grid to the console.</li>
<li>It helps visualize the current state of the grid during the solving process.</li>
</ul>
</li>
</ol>
<p>Overall, the code structure follows a systematic approach to solving the crossword puzzle problem, with separate methods for different tasks such as checking placement validity, tracking character placement, and handling exceptions.</p>
<h2 id="the-solution-class">The <code>Solution</code> Class</h2>
<p>The provided code is the main class that reads input data, solves the crossword puzzle, and writes the solution to an output file. Here is a detailed explanation of each section:</p>
<ol>
<li>
<p><code>Solution</code> Class:</p>
<ul>
<li>This class contains the main method that serves as the entry point of the program.</li>
<li>It reads input from the user, processes the data, solves the crossword puzzle, and writes the solution to an output file.</li>
</ul>
</li>
<li>
<p><code>main</code> Method:</p>
<ul>
<li>The <code>main</code> method takes an array of strings as input arguments and throws an IOException.</li>
<li>It initializes a <code>BufferedReader</code> to read input from the console and a <code>BufferedWriter</code> to write output to a file specified in the <code>OUTPUT_PATH</code> environment variable.</li>
<li>It creates an empty list <code>crossword</code> to store the rows of the crossword grid.</li>
<li>It reads 10 lines of input representing the rows of the crossword grid and adds them to the <code>crossword</code> list.</li>
<li>It reads a single line of input containing the words to be placed in the crossword grid.</li>
<li>It calls the <code>crosswordPuzzle</code> method from the <code>Result</code> class to solve the crossword puzzle using the input grid and words.</li>
<li>It iterates through the solved puzzle (<code>result</code> list) and writes each row to the output file using the <code>BufferedWriter</code>.</li>
<li>It writes a newline character after writing each row to separate them in the output file.</li>
<li>Finally, it closes the <code>BufferedReader</code> and <code>BufferedWriter</code> to release system resources.</li>
</ul>
</li>
</ol>
<p>Overall, the <code>Solution</code> class orchestrates the process of reading input data, solving the crossword puzzle, and writing the solution to an output file. It acts as the control center of the program, coordinating the flow of data and interactions between different components.</p>
]]></content:encoded>
        </item>
    </channel>
</rss>